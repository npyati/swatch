<head>
    <title>swatch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23ff6b6b'/%3E%3Cstop offset='50%25' style='stop-color:%234ecdc4'/%3E%3Cstop offset='100%25' style='stop-color:%23ffe66d'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dongle:wght@700&family=Koulen&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background-color: #d3dcd9;
            margin: 0;
            padding: 0;
        }

        #wrapper {
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        #fixed-header {
            position: sticky;
            top: 0;
            background-color: #d3dcd9;
            padding: 20px;
            z-index: 100;
        }

        #scrollable-content {
            padding: 0 20px 20px 20px;
        }

        #mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            background-color: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            font-family: 'Koulen', cursive;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
            color: rgba(0, 0, 0, 0.7);
        }

        body.dark-bg .mode-btn {
            color: rgba(255, 255, 255, 0.7);
        }

        .mode-btn.active {
            opacity: 1;
            border-bottom-color: rgba(0, 0, 0, 0.8);
            color: rgba(0, 0, 0, 0.9);
        }

        body.dark-bg .mode-btn.active {
            border-bottom-color: rgba(255, 255, 255, 0.9);
            color: rgba(255, 255, 255, 0.9);
        }

        .mode-btn:hover {
            opacity: 0.8;
        }

        .mode-btn svg {
            display: block;
            margin: 0 auto;
            vertical-align: middle;
        }

        #output {
            width: 100%;
            background-color: black;
            color: white;
            border-radius: 10px;
            font-family: 'Koulen', cursive;
            font-size: clamp(2rem, 8vw, 4rem);
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
            margin-bottom: 15px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body.dark-bg #output {
            box-shadow: 0 4px 8px 0 rgba(255, 255, 255, 0.1), 0 6px 20px 0 rgba(255, 255, 255, 0.05);
        }

        #picker-content {
            width: 100%;
            text-align: left;
            padding: 0 20px;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #gradient-content {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            overflow: hidden;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #game-content {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            overflow: hidden;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #game-split {
            display: flex;
            width: 100%;
            height: 100%;
        }

        #game-target, #game-guess {
            width: 50%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #game-guess {
            background-color: #000;
        }

        .game-overlay {
            font-family: 'Koulen', cursive;
            font-size: 1.2rem;
            color: white;
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        #gradient-preview {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #gradient-controls {
            display: none;
            margin-bottom: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        body.gradient-mode #gradient-controls {
            display: block;
            animation: fadeIn 0.3s ease forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        body.gradient-mode #picker-content {
            display: none;
        }

        body.gradient-mode #gradient-content {
            display: flex;
        }

        body.picker-mode #gradient-content,
        body.game-mode #gradient-content {
            display: none;
        }

        body.game-mode #game-content {
            display: flex;
        }

        body.picker-mode #game-content,
        body.gradient-mode #game-content {
            display: none;
        }

        body.gradient-mode #output {
            background: none !important;
            padding: 0;
        }

        body.game-mode #output {
            background: none !important;
            padding: 0;
            justify-content: normal;
            align-items: normal;
        }

        body.gradient-mode .slider {
            display: none;
        }

        body.gradient-mode #palette-section {
            border-top: none;
            margin-top: 0;
            padding-top: 0;
        }

        body.picker-mode #gradient-controls,
        body.game-mode #gradient-controls {
            display: none;
        }

        body.picker-mode #game-controls,
        body.gradient-mode #game-controls {
            display: none;
        }

        body.game-mode .slider {
            display: none;
        }

        body.game-mode #palette-section {
            display: none;
        }

        body.game-mode #picker-content {
            display: none;
        }

        .game-slider {
            width: 100%;
            margin-bottom: 15px;
            cursor: pointer;
        }

        #score-result {
            font-family: 'Koulen', cursive;
            font-size: 1.5rem;
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            font-family: 'Koulen', cursive;
            font-size: 0.9rem;
            margin-bottom: 6px;
            display: block;
            opacity: 0.6;
        }

        body.dark-bg .control-label {
            color: rgba(255, 255, 255, 0.7);
        }

        #palette-selector-group {
            display: none;
        }

        .gradient-options {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .gradient-option {
            padding: 6px 12px;
            background-color: transparent;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Koulen', cursive;
            font-size: 0.9rem;
            transition: all 0.2s;
            opacity: 0.6;
        }

        body.dark-bg .gradient-option {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.8);
        }

        .gradient-option:hover {
            opacity: 0.8;
        }

        .gradient-option.active {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.08);
            border-color: rgba(0, 0, 0, 0.4);
        }

        body.dark-bg .gradient-option.active {
            background-color: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #overlay-controls {
            display: none;
        }

        body.gradient-mode #overlay-controls {
            display: block;
        }

        #gradient-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .overlay-slider {
            width: 100%;
            height: 30px;
            margin-bottom: 12px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            outline: none;
        }

        body.dark-bg .overlay-slider {
            background: rgba(255, 255, 255, 0.15);
        }

        .overlay-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            cursor: pointer;
        }

        body.dark-bg .overlay-slider::-webkit-slider-thumb {
            background: rgba(255, 255, 255, 0.8);
        }

        .overlay-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            cursor: pointer;
            border: none;
        }

        body.dark-bg .overlay-slider::-moz-range-thumb {
            background: rgba(255, 255, 255, 0.8);
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-family: 'Koulen', cursive;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            background-color: transparent;
        }

        body.dark-bg .action-btn {
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.9);
        }

        .action-btn:hover {
            background-color: rgba(0, 0, 0, 0.08);
        }

        body.dark-bg .action-btn:hover {
            background-color: rgba(255, 255, 255, 0.12);
        }

        .action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .text {
            background-color: transparent;
            color: white;
            border: 0;
            font-size: clamp(1.5rem, 6vw, 3rem);
            font-family: 'Koulen', cursive;
            max-width: 70%;
            display: inline-block;
        }

        input.text:focus {
            outline:none;
        }

        #rgb {
            white-space: nowrap;
        }

        .slider {
            border-radius: 10px;
            display: block;
            width: 100%;
            height: clamp(30px, 8vw, 50px);
            margin-bottom: 15px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, rgb(0, 0, 0), rgb(0, 0, 255));
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
            touch-action: none;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #red {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(255, 0, 0));
        }

        #green {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(0, 255, 0));
        }

        #blue {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(0, 0, 255));
        }

        #brightness {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(255, 255, 255));
    }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 60%;
            aspect-ratio: 1/1;
            border-radius: 45%;
            border: 3px solid white;
            background: rgba(255,255,255,0.35);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            height: clamp(18px, 5vw, 30px);
            width: clamp(18px, 5vw, 30px);
            border-radius: 50%;
            border: 3px solid white;
            background: rgba(255,255,255,0.35);
            cursor: pointer;
        }

        @media (max-width: 480px) {
            #wrapper {
                padding: 15px;
            }

            #output {
                padding: 20px;
                margin-bottom: 15px;
            }

            .preview-swatch {
                width: 16px;
                height: 16px;
            }

            .palette-preview {
                max-width: 110px;
                gap: 3px;
            }

            /* Ensure minimum 44px touch targets */
            .mode-btn {
                min-height: 44px;
                padding: 10px;
            }

            .action-btn {
                min-height: 44px;
            }

            .icon-btn {
                min-width: 44px;
                min-height: 44px;
            }
        }

        @media (min-width: 768px) {
            #output {
                padding: 30px;
            }
        }

        #palette-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid rgba(0, 0, 0, 0.1);
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .palette-row {
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 10px;
        }

        body.gradient-mode .palette-row {
            cursor: pointer;
            margin-bottom: 10px;
            padding: 10px;
            pointer-events: auto;
        }

        body.gradient-mode .palette-row:hover {
            background-color: rgba(0, 0, 0, 0.06);
        }

        body.gradient-mode .palette-row.selected {
            background-color: rgba(0, 0, 0, 0.15);
            outline: 3px solid rgba(0, 0, 0, 0.5);
            outline-offset: -3px;
        }

        body.dark-bg.gradient-mode .palette-row:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }

        body.dark-bg.gradient-mode .palette-row.selected {
            background-color: rgba(255, 255, 255, 0.15);
            outline: 3px solid rgba(255, 255, 255, 0.6);
            outline-offset: -3px;
        }

        .palette-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        body.gradient-mode .palette-header {
            margin-bottom: 0;
        }

        body.gradient-mode .palette-name {
            pointer-events: none;
            border-bottom-color: transparent !important;
        }

        .palette-preview {
            display: none;
            gap: 4px;
            margin-left: 10px;
            flex-wrap: wrap;
            max-width: 140px;
        }

        body.gradient-mode .palette-preview {
            display: flex;
        }

        .preview-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        body.gradient-mode .palette-container {
            display: none;
        }

        body.gradient-mode .palette-actions,
        body.gradient-mode #new-palette-btn {
            display: none;
        }

        .palette-name {
            font-family: 'Koulen', cursive;
            font-size: 1.2rem;
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 5px;
            transition: border-color 0.2s;
        }

        .palette-name:hover {
            border-bottom-color: rgba(0, 0, 0, 0.2);
        }

        .palette-name:focus {
            outline: none;
            border-bottom-color: rgba(0, 0, 0, 0.5);
        }

        .palette-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border: none;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .icon-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .palette-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
        }

        .add-to-palette {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            background-color: transparent;
            border: 3px dashed rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-family: monospace;
            line-height: 1;
            padding-top: 0.1em;
            color: rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .add-to-palette:hover {
            border-color: rgba(0, 0, 0, 0.5);
            color: rgba(0, 0, 0, 0.5);
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .add-to-palette:active {
            transform: scale(0.95);
        }

        .palette-colors {
            display: contents;
        }

        #new-palette-btn {
            width: 100%;
            padding: 12px;
            background-color: transparent;
            border: 2px dashed rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-family: 'Koulen', cursive;
            font-size: 1rem;
            color: rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.2s;
        }

        #new-palette-btn:hover {
            border-color: rgba(0, 0, 0, 0.4);
            color: rgba(0, 0, 0, 0.6);
            background-color: rgba(0, 0, 0, 0.02);
        }

        .swatch {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .swatch:active {
            transform: scale(0.95);
        }

        .swatch .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
        }

        .swatch:hover .delete-btn {
            display: flex;
        }

        @media (max-width: 480px) {
            .palette-container {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            }
        }

        /* Dark background adaptations */
        body.dark-bg #palette-section {
            border-top-color: rgba(255, 255, 255, 0.2);
        }

        body.dark-bg .palette-row {
            background-color: rgba(255, 255, 255, 0.05);
        }

        body.dark-bg .palette-name {
            color: rgba(255, 255, 255, 0.9);
        }

        body.dark-bg .palette-name:hover {
            border-bottom-color: rgba(255, 255, 255, 0.3);
        }

        body.dark-bg .palette-name:focus {
            border-bottom-color: rgba(255, 255, 255, 0.6);
        }

        body.dark-bg .icon-btn {
            background-color: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        body.dark-bg .icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.25);
        }

        body.dark-bg .add-to-palette {
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        body.dark-bg .add-to-palette:hover {
            border-color: rgba(255, 255, 255, 0.6);
            color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 8px rgba(255, 255, 255, 0.15);
        }

        body.dark-bg #new-palette-btn {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.5);
        }

        body.dark-bg #new-palette-btn:hover {
            border-color: rgba(255, 255, 255, 0.5);
            color: rgba(255, 255, 255, 0.7);
            background-color: rgba(255, 255, 255, 0.03);
        }

        /* Color Harmonies */
        #color-harmonies {
            margin-bottom: 20px;
        }

        body.gradient-mode #color-harmonies,
        body.game-mode #color-harmonies {
            display: none;
        }

        .harmony-section {
            margin-bottom: 15px;
        }

        .harmony-label {
            font-family: 'Koulen', cursive;
            font-size: 0.85rem;
            margin-bottom: 6px;
            opacity: 0.6;
        }

        body.dark-bg .harmony-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .harmony-swatches {
            display: flex;
            gap: 8px;
        }

        .harmony-swatch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .harmony-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .harmony-swatch:active {
            transform: scale(0.95);
        }

        @media (max-width: 480px) {
            .harmony-swatch {
                width: 40px;
                height: 40px;
            }

            /* Better touch feedback on mobile */
            .mode-btn:active {
                transform: scale(0.92);
                opacity: 1;
            }

            .action-btn:active {
                transform: scale(0.95);
            }

            .gradient-option:active {
                transform: scale(0.95);
            }

            .icon-btn:active {
                transform: scale(0.9);
            }

            #new-palette-btn:active {
                transform: scale(0.98);
            }
        }

        /* Empty states */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(0, 0, 0, 0.4);
            font-family: 'Koulen', cursive;
            font-size: 1.1rem;
        }

        body.dark-bg .empty-state {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Drag and drop feedback */
        body.drag-over::before {
            content: 'Drop to import';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            border: 3px dashed rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Koulen', cursive;
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            pointer-events: none;
        }

        body.dark-bg.drag-over::before {
            background: rgba(255, 255, 255, 0.85);
            color: rgba(0, 0, 0, 0.9);
            border-color: rgba(0, 0, 0, 0.3);
        }

        /* Toast notifications */
        #toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Koulen', cursive;
            font-size: 0.95rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        body.dark-bg #toast {
            background-color: rgba(255, 255, 255, 0.9);
            color: rgba(0, 0, 0, 0.9);
        }

        /* Drag and drop styles */
        .palette-row {
            cursor: grab;
            transition: all 0.2s;
        }

        .palette-row:active {
            cursor: grabbing;
        }

        .palette-row.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }

        .palette-row.drag-over {
            border-top: 3px solid rgba(0, 0, 0, 0.5);
        }

        body.dark-bg .palette-row.drag-over {
            border-top-color: rgba(255, 255, 255, 0.6);
        }

        .swatch {
            cursor: grab;
        }

        .swatch:active {
            cursor: grabbing;
        }

        .swatch.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }

        .swatch.dragging .delete-btn {
            display: none !important;
        }

        .swatch.drag-over {
            outline: 3px solid rgba(0, 0, 0, 0.6);
            outline-offset: -3px;
        }

        body.dark-bg .swatch.drag-over {
            outline-color: rgba(255, 255, 255, 0.7);
        }

    </style>
    <script>
        // Utility helpers for vanilla JS
        function qs(selector, context = document) {
            return context.querySelector(selector);
        }
        function qsa(selector, context = document) {
            return Array.from(context.querySelectorAll(selector));
        }
        function createElement(tag, className, content) {
            const el = document.createElement(tag);
            if (className) el.className = className;
            if (content) el.innerHTML = content;
            return el;
        }

        var [red,green,blue]=[0,0,0];
        var hex = "000";
        var hold = [0,0,0];
        var palettes = [];
        var nextPaletteId = 1;
        var currentMode = 'picker';
        var selectedPaletteId = null;
        var currentGradientType = 'linear-right';
        var overlaySettings = {
            enabled: false,
            triangleSize: 50,
            regularity: 50,
            depth: 30,
            polygonType: 'triangles'
        };

        var gameState = {
            targetColor: { r: 0, g: 0, b: 0 },
            guessColor: { r: 0, g: 0, b: 0 },
            hasGuessed: false
        };

        // Drag-and-drop state
        var dragState = {
            draggedPaletteId: null,
            draggedSwatchIndex: null,
            draggedSwatchPaletteId: null
        };

        function update(elem){

            //Update RGB values if new hex code entered
            if (elem == "hex") {
                [red,green,blue] = hexToRGB(hex);
            }

            //Update red
            qs('#red').style.background = `linear-gradient(to right, rgb(0,${green},${blue}), rgb(255,${green},${blue}))`;

            //Update green
            qs('#green').style.background = `linear-gradient(to right, rgb(${red},0,${blue}), rgb(${red},255,${blue}))`;

            //Update blue
            qs('#blue').style.background = `linear-gradient(to right, rgb(${red},${green},0), rgb(${red},${green},255))`;

            //Update RGB sliders
            if(['brightness','hex'].includes(elem)){
                //If brightness slider, update sliders with new red,green,blue values. Don't update hold.
                qs('#red').value = red;
                qs('#green').value = green;
                qs('#blue').value = blue;
            }

            if (['red','green','blue','hex'].includes(elem)) {
                //If non-brightness slider, store new color values in hold
                hold = [red,green,blue,get_brightness([red,green,blue])/2.55];
                   //Set gradient and position for brightness slider
                qs('#brightness').style.background = `linear-gradient(to right, rgb(0,0,0), rgb(${hold[0]},${hold[1]},${hold[2]}) ${hold[3]}%, rgb(255,255,255))`;
                qs('#brightness').value = hold[3];
            }

            //Update readout
            qs('#rgb').innerHTML = `${red}, ${green}, ${blue}`;

            if(!(['hex'].includes(elem))) {
                hex = "#"+rgbToHex(red,green,blue);
            }
            qs('#hex').value = hex;

            qsa('#output, .text').forEach(el => el.style.background = hex);

            //Set text color
            var b = get_brightness();
            var contrast = Math.round((255-b)/255)*255;
            var contrast2 = 255-b;
            qsa('#output, .text').forEach(el => el.style.color = `rgb(${contrast},${contrast},${contrast})`);
            const bgColor = `rgb(${contrast2},${contrast2},${contrast2})`;
            document.body.style.backgroundColor = bgColor;
            qs('#fixed-header').style.backgroundColor = bgColor;

            // Toggle dark background class for palette interface
            if (contrast2 < 128) {
                document.body.classList.add('dark-bg');
            } else {
                document.body.classList.remove('dark-bg');
            }

            // Update color harmonies
            updateColorHarmonies();
        };

        function rgbToHex(r, g, b) {
          if (r > 255 || g > 255 || b > 255 || r < 0 || g < 0 || b < 0)
        throw new Error('Invalid color component');
        return ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function showToast(message, duration = 2000) {
            const toast = qs('#toast');
            toast.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        function isValidHexCode(str) {
        const regex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
        return regex.test(str);
        }

        function hexToRGB(hex) {
        // Remove the '#' from the beginning
        hex = hex.replace('#', '');
        
        // Check if the hex code is in the shorthand form (3 characters)
        if (hex.length === 3) {
            // Expand the shorthand form to full form (e.g., 'ABC' -> 'AABBCC')
            hex = hex.split('').map(char => char + char).join('');
        }

        // Convert hex code to an RGB array
        const rgb = [];
        for (let i = 0; i < hex.length; i += 2) {
            const decimalValue = parseInt(hex.substring(i, i + 2), 16);
            rgb.push(decimalValue);
        }

        return rgb;
        }

        function get_brightness(input=[red,green,blue]) {
            var b = 0;
            [red,green,blue].forEach(function(element){
                b += parseInt(element);
            });
            return Math.round(b/3);
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h * 360, s * 100, l * 100];
        }

        function hslToRgb(h, s, l) {
            h = h / 360;
            s = s / 100;
            l = l / 100;
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function getColorHarmonies(r, g, b) {
            const [h, s, l] = rgbToHsl(r, g, b);
            const harmonies = {};

            // Complementary (180°)
            const compH = (h + 180) % 360;
            const compRgb = hslToRgb(compH, s, l);
            harmonies.complementary = '#' + rgbToHex(compRgb[0], compRgb[1], compRgb[2]);

            // Analogous (±30°)
            const analog1H = (h + 30) % 360;
            const analog2H = (h - 30 + 360) % 360;
            harmonies.analogous1 = '#' + rgbToHex(...hslToRgb(analog1H, s, l));
            harmonies.analogous2 = '#' + rgbToHex(...hslToRgb(analog2H, s, l));

            // Triadic (120° intervals)
            const tri1H = (h + 120) % 360;
            const tri2H = (h + 240) % 360;
            harmonies.triadic1 = '#' + rgbToHex(...hslToRgb(tri1H, s, l));
            harmonies.triadic2 = '#' + rgbToHex(...hslToRgb(tri2H, s, l));

            // Split Complementary (150°, 210°)
            const split1H = (h + 150) % 360;
            const split2H = (h + 210) % 360;
            harmonies.splitComp1 = '#' + rgbToHex(...hslToRgb(split1H, s, l));
            harmonies.splitComp2 = '#' + rgbToHex(...hslToRgb(split2H, s, l));

            return harmonies;
        }

        function updateColorHarmonies() {
            const harmonies = getColorHarmonies(red, green, blue);

            // Update complementary
            qs('#harmony-comp').style.backgroundColor = harmonies.complementary;

            // Update analogous
            qs('#harmony-analog1').style.backgroundColor = harmonies.analogous1;
            qs('#harmony-analog2').style.backgroundColor = harmonies.analogous2;

            // Update triadic
            qs('#harmony-tri1').style.backgroundColor = harmonies.triadic1;
            qs('#harmony-tri2').style.backgroundColor = harmonies.triadic2;

            // Update split complementary
            qs('#harmony-split1').style.backgroundColor = harmonies.splitComp1;
            qs('#harmony-split2').style.backgroundColor = harmonies.splitComp2;
        }

        function exportColorAsSVG(hexColor) {
            const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
  <metadata>
    <swatch-color>${hexColor}</swatch-color>
  </metadata>
  <rect width="200" height="200" fill="${hexColor}"/>
  <text x="100" y="190" font-family="Arial, sans-serif" font-size="14" fill="${getContrastColor(hexColor)}" text-anchor="middle">${hexColor}</text>
</svg>`;

            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `color-${hexColor.substring(1)}.svg`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`Exported ${hexColor} as SVG`);
        }

        function exportPaletteAsSVG(palette) {
            const numColors = palette.colors.length;
            const width = 400;
            const height = 200;
            const stripeWidth = width / numColors;

            let stripes = '';
            palette.colors.forEach((color, i) => {
                stripes += `  <rect x="${i * stripeWidth}" y="0" width="${stripeWidth}" height="${height}" fill="${color}"/>\n`;
            });

            const colorsData = palette.colors.join(',');
            const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <metadata>
    <swatch-palette name="${palette.name}">${colorsData}</swatch-palette>
  </metadata>
${stripes}
  <text x="${width/2}" y="${height - 15}" font-family="Arial, sans-serif" font-size="16" fill="rgba(255,255,255,0.9)" text-anchor="middle" style="text-shadow: 0 1px 3px rgba(0,0,0,0.5);">${palette.name}</text>
</svg>`;

            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `palette-${palette.name.toLowerCase().replace(/\s+/g, '-')}.svg`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`Exported palette as SVG`);
        }

        function getContrastColor(hexColor) {
            const rgb = hexToRGB(hexColor);
            const brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
            return brightness > 128 ? '#000000' : '#FFFFFF';
        }

        function parseSVGFile(svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');

            // Check for single color
            const colorMetadata = doc.querySelector('swatch-color');
            if (colorMetadata) {
                let hexColor = colorMetadata.textContent.trim();
                // Ensure hex has # prefix
                if (!hexColor.startsWith('#')) {
                    hexColor = '#' + hexColor;
                }
                // Normalize to 6-character format if needed
                if (hexColor.length === 4) {
                    hexColor = '#' + hexColor[1] + hexColor[1] + hexColor[2] + hexColor[2] + hexColor[3] + hexColor[3];
                }
                loadColor(hexColor);
                showToast(`Imported color ${hexColor}`);
                switchMode('picker');
                return;
            }

            // Check for palette
            const paletteMetadata = doc.querySelector('swatch-palette');
            if (paletteMetadata) {
                const paletteName = paletteMetadata.getAttribute('name') || 'Imported Palette';
                const colorsData = paletteMetadata.textContent.trim();
                const colors = colorsData.split(',').map(c => c.trim());

                const palette = {
                    id: nextPaletteId++,
                    name: paletteName,
                    colors: colors
                };
                palettes.push(palette);
                savePalettes();
                renderAllPalettes();
                showToast(`Imported palette: ${paletteName}`);
                return;
            }

            showToast('Invalid SVG file - no color data found');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            document.body.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];
            if (!file.name.endsWith('.svg')) {
                showToast('Please drop an SVG file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                parseSVGFile(event.target.result);
            };
            reader.readAsText(file);
        }

        function createNewPalette() {
            const palette = {
                id: nextPaletteId++,
                name: `Palette ${palettes.length + 1}`,
                colors: []
            };
            palettes.push(palette);
            savePalettes();
            renderAllPalettes();
            showToast(`Created ${palette.name}`);
        }

        function addToPalette(paletteId) {
            const palette = palettes.find(p => p.id === paletteId);
            // Ensure hex has # prefix
            const normalizedHex = hex.startsWith('#') ? hex : '#' + hex;
            if (palette && !palette.colors.includes(normalizedHex) && palette.colors.length < 6) {
                palette.colors.push(normalizedHex);
                savePalettes();
                renderAllPalettes();
                showToast(`Added ${normalizedHex} to ${palette.name}`);
            }
        }

        function removeFromPalette(paletteId, color) {
            const palette = palettes.find(p => p.id === paletteId);
            if (palette) {
                palette.colors = palette.colors.filter(c => c !== color);
                savePalettes();
                renderAllPalettes();
            }
        }

        function deletePalette(paletteId) {
            const palette = palettes.find(p => p.id === paletteId);
            const paletteName = palette ? palette.name : 'Palette';
            palettes = palettes.filter(p => p.id !== paletteId);
            // Reset selected palette if it was deleted
            if (selectedPaletteId === paletteId) {
                selectedPaletteId = palettes.length > 0 ? palettes[0].id : null;
                if (currentMode === 'gradient') {
                    updateGradientDisplay();
                }
            }
            savePalettes();
            renderAllPalettes();
            showToast(`Deleted ${paletteName}`);
        }

        function renamePalette(paletteId, newName) {
            const palette = palettes.find(p => p.id === paletteId);
            if (palette) {
                palette.name = newName;
                savePalettes();
            }
        }

        function loadColor(color) {
            hex = color;
            update('hex');
        }

        function savePalettes() {
            localStorage.setItem('colorPalettes', JSON.stringify({
                palettes: palettes,
                nextId: nextPaletteId
            }));
        }

        function loadPalettes() {
            const saved = localStorage.getItem('colorPalettes');
            if (saved) {
                const data = JSON.parse(saved);
                palettes = data.palettes || [];
                nextPaletteId = data.nextId || 1;

                // Fix any colors missing # prefix
                palettes.forEach(palette => {
                    palette.colors = palette.colors.map(color =>
                        color.startsWith('#') ? color : '#' + color
                    );
                });
                savePalettes(); // Save the fixed palettes
            }
            if (palettes.length === 0) {
                createNewPalette();
            }
            renderAllPalettes();
        }

        function switchMode(mode) {
            currentMode = mode;
            document.body.classList.remove('picker-mode', 'gradient-mode', 'game-mode');
            document.body.classList.add(mode + '-mode');
            qsa('.mode-btn').forEach(btn => btn.classList.remove('active'));
            qs(`[data-mode="${mode}"]`).classList.add('active');

            if (mode === 'gradient') {
                if (!selectedPaletteId && palettes.length > 0) {
                    selectedPaletteId = palettes[0].id;
                }
                // Refresh overlay toggle state
                qsa('.overlay-toggle').forEach(el => el.classList.remove('active'));
                const activeToggle = qs(`.overlay-toggle[data-overlay-enabled="${overlaySettings.enabled}"]`);
                if (activeToggle) activeToggle.classList.add('active');

                updateGradientDisplay();
                updatePaletteSelector();
            } else if (mode === 'game') {
                // Initialize game with first round
                startNewRound();
            }
        }

        function updatePaletteSelector() {
            // Update palette row selection in gradient mode
            qsa('.palette-row').forEach(row => row.classList.remove('selected'));
            const selectedRow = qs(`.palette-row[data-palette-id="${selectedPaletteId}"]`);
            if (selectedRow) selectedRow.classList.add('selected');
        }

        function updateGradientDisplay() {
            const palette = palettes.find(p => p.id == selectedPaletteId);
            if (!palette || palette.colors.length === 0) {
                qs('#gradient-preview').style.background = 'rgba(0,0,0,0.05)';
                qs('#gradient-preview').innerHTML = `
                    <div class="empty-state">
                        <div>${!palette ? 'No palette selected' : 'This palette has no colors yet'}</div>
                        <div style="font-size: 0.9rem; margin-top: 8px; opacity: 0.7;">${!palette ? 'Select a palette below' : 'Switch to Picker mode to add colors'}</div>
                    </div>
                `;
                qs('#gradient-canvas').style.display = 'none';
                qsa('.action-btn').forEach(btn => btn.disabled = true);
                return;
            }

            qsa('.action-btn').forEach(btn => btn.disabled = false);
            qs('#gradient-preview').innerHTML = ''; // Clear any empty state message
            const colors = palette.colors.length === 1
                ? [palette.colors[0], palette.colors[0]]
                : palette.colors;

            if (overlaySettings.enabled) {
                // Switch to canvas rendering
                qs('#gradient-preview').style.display = 'none';
                qs('#gradient-canvas').style.display = 'block';

                const canvas = document.getElementById('gradient-canvas');
                const container = document.getElementById('gradient-content');

                // Set canvas size to match container
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;

                // Render with overlay
                renderGradientToCanvas(
                    canvas,
                    colors,
                    currentGradientType,
                    true,
                    overlaySettings
                );
            } else {
                // Use CSS gradient
                qs('#gradient-canvas').style.display = 'none';
                qs('#gradient-preview').style.display = 'block';

                const colorStops = colors.join(', ');
                let gradientCSS = '';

                switch(currentGradientType) {
                    case 'linear-right':
                        gradientCSS = `linear-gradient(to right, ${colorStops})`;
                        break;
                    case 'linear-bottom':
                        gradientCSS = `linear-gradient(to bottom, ${colorStops})`;
                        break;
                    case 'linear-diagonal':
                        gradientCSS = `linear-gradient(135deg, ${colorStops})`;
                        break;
                    case 'radial':
                        gradientCSS = `radial-gradient(circle, ${colorStops})`;
                        break;
                }

                qs('#gradient-preview').style.background = gradientCSS;
            }
        }

        function selectGradientType(type) {
            currentGradientType = type;
            qsa('.gradient-option').forEach(opt => opt.classList.remove('active'));
            qs(`[data-gradient-type="${type}"]`).classList.add('active');
            updateGradientDisplay();
        }

        function copyGradientCSS() {
            const palette = palettes.find(p => p.id === selectedPaletteId);
            if (!palette || palette.colors.length < 2) return;

            const colorStops = palette.colors.join(', ');
            let gradientCSS = '';

            switch(currentGradientType) {
                case 'linear-right':
                    gradientCSS = `background: linear-gradient(to right, ${colorStops});`;
                    break;
                case 'linear-bottom':
                    gradientCSS = `background: linear-gradient(to bottom, ${colorStops});`;
                    break;
                case 'linear-diagonal':
                    gradientCSS = `background: linear-gradient(135deg, ${colorStops});`;
                    break;
                case 'radial':
                    gradientCSS = `background: radial-gradient(circle, ${colorStops});`;
                    break;
            }

            navigator.clipboard.writeText(gradientCSS).then(() => {
                showToast('CSS copied to clipboard');
            });
        }

        function downloadGradientPNG() {
            const palette = palettes.find(p => p.id == selectedPaletteId);
            if (!palette || palette.colors.length === 0) return;

            const btn = qs('#download-png-btn');
            const originalText = btn.textContent;
            btn.textContent = 'Generating...';
            btn.disabled = true;

            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                const canvas = document.createElement('canvas');
                canvas.width = 1920;
                canvas.height = 1080;

                const colors = palette.colors.length === 1
                    ? [palette.colors[0], palette.colors[0]]
                    : palette.colors;

                // Render with or without overlay
                renderGradientToCanvas(
                    canvas,
                    colors,
                    currentGradientType,
                    overlaySettings.enabled,
                    overlaySettings
                );

                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const overlayPrefix = overlaySettings.enabled ? 'lowpoly-' : '';
                    a.download = `${overlayPrefix}gradient-${palette.name.toLowerCase().replace(/\s+/g, '-')}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('PNG downloaded');

                    // Reset button
                    btn.textContent = originalText;
                    btn.disabled = false;
                });
            }, 50);
        }

        // Delaunay Triangulation - Bowyer-Watson Algorithm
        function delaunayTriangulation(points) {
            if (points.length < 3) return [];

            // Find bounding box
            var minX = Infinity, minY = Infinity;
            var maxX = -Infinity, maxY = -Infinity;
            points.forEach(function(p) {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });

            // Create super-triangle
            var dx = maxX - minX;
            var dy = maxY - minY;
            var deltaMax = Math.max(dx, dy) * 2;

            var p1 = {x: minX - 1, y: minY - 1};
            var p2 = {x: minX - 1, y: maxY + deltaMax};
            var p3 = {x: maxX + deltaMax, y: minY - 1};

            var triangles = [{p1: p1, p2: p2, p3: p3}];

            // Add points incrementally
            points.forEach(function(point) {
                var badTriangles = [];

                // Find bad triangles
                triangles.forEach(function(triangle) {
                    var circle = getCircumcircle(triangle.p1, triangle.p2, triangle.p3);
                    if (isInsideCircumcircle(point, circle)) {
                        badTriangles.push(triangle);
                    }
                });

                // Find boundary polygon
                var polygon = [];
                badTriangles.forEach(function(triangle) {
                    var edges = [
                        {p1: triangle.p1, p2: triangle.p2},
                        {p1: triangle.p2, p2: triangle.p3},
                        {p1: triangle.p3, p2: triangle.p1}
                    ];

                    edges.forEach(function(edge) {
                        var shared = false;
                        badTriangles.forEach(function(other) {
                            if (other === triangle) return;
                            if (edgeInTriangle(edge, other)) {
                                shared = true;
                            }
                        });

                        if (!shared) {
                            polygon.push(edge);
                        }
                    });
                });

                // Remove bad triangles
                triangles = triangles.filter(function(t) {
                    return badTriangles.indexOf(t) === -1;
                });

                // Add new triangles
                polygon.forEach(function(edge) {
                    triangles.push({
                        p1: edge.p1,
                        p2: edge.p2,
                        p3: point
                    });
                });
            });

            // Remove triangles connected to super-triangle
            triangles = triangles.filter(function(triangle) {
                return triangle.p1 !== p1 && triangle.p1 !== p2 && triangle.p1 !== p3 &&
                       triangle.p2 !== p1 && triangle.p2 !== p2 && triangle.p2 !== p3 &&
                       triangle.p3 !== p1 && triangle.p3 !== p2 && triangle.p3 !== p3;
            });

            return triangles;
        }

        function getCircumcircle(p1, p2, p3) {
            var ax = p1.x, ay = p1.y;
            var bx = p2.x, by = p2.y;
            var cx = p3.x, cy = p3.y;

            var d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 0.0001) {
                return {x: ax, y: ay, radius: Infinity};
            }

            var ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            var uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;

            var radius = Math.sqrt((ax - ux) * (ax - ux) + (ay - uy) * (ay - uy));

            return {x: ux, y: uy, radius: radius};
        }

        function isInsideCircumcircle(point, circle) {
            var dx = point.x - circle.x;
            var dy = point.y - circle.y;
            var distSq = dx * dx + dy * dy;
            return distSq < circle.radius * circle.radius;
        }

        function edgeInTriangle(edge, triangle) {
            var edges = [
                {p1: triangle.p1, p2: triangle.p2},
                {p1: triangle.p2, p2: triangle.p3},
                {p1: triangle.p3, p2: triangle.p1}
            ];

            for (var i = 0; i < edges.length; i++) {
                var e = edges[i];
                if ((e.p1 === edge.p1 && e.p2 === edge.p2) ||
                    (e.p1 === edge.p2 && e.p2 === edge.p1)) {
                    return true;
                }
            }
            return false;
        }

        function generatePoints(width, height, cellSize, jitter) {
            var points = [];
            var jitterAmount = cellSize * (jitter / 100);

            for (var y = -cellSize; y < height + cellSize; y += cellSize) {
                for (var x = -cellSize; x < width + cellSize; x += cellSize) {
                    var jitterX = (Math.random() - 0.5) * jitterAmount;
                    var jitterY = (Math.random() - 0.5) * jitterAmount;
                    points.push({
                        x: x + jitterX,
                        y: y + jitterY
                    });
                }
            }

            return points;
        }

        function computeVoronoiDiagram(points, triangles, width, height) {
            var cells = [];

            // Build point-to-triangles mapping
            var pointTriangles = {};
            points.forEach(function(p, i) {
                pointTriangles[i] = [];
            });

            triangles.forEach(function(tri) {
                // Find indices of triangle vertices in points array
                points.forEach(function(p, i) {
                    if (p === tri.p1 || p === tri.p2 || p === tri.p3) {
                        pointTriangles[i].push(tri);
                    }
                });
            });

            // For each point, build its Voronoi cell
            points.forEach(function(point, pointIndex) {
                var tris = pointTriangles[pointIndex];
                if (tris.length === 0) return;

                // Get circumcenters of all triangles containing this point
                var circumcenters = tris.map(function(tri) {
                    var circle = getCircumcircle(tri.p1, tri.p2, tri.p3);
                    return {x: circle.x, y: circle.y, triangle: tri};
                });

                // Sort circumcenters in circular order around the point
                circumcenters.sort(function(a, b) {
                    var angleA = Math.atan2(a.y - point.y, a.x - point.x);
                    var angleB = Math.atan2(b.y - point.y, b.x - point.x);
                    return angleA - angleB;
                });

                // Extract vertices
                var vertices = circumcenters.map(function(cc) {
                    return {x: cc.x, y: cc.y};
                });

                // Clip cell to canvas bounds
                vertices = clipCellToCanvas(vertices, width, height);

                if (vertices.length >= 3) {
                    cells.push({
                        point: point,
                        vertices: vertices
                    });
                }
            });

            return cells;
        }

        function clipCellToCanvas(vertices, width, height) {
            if (vertices.length === 0) return [];

            // Clip against four edges using Sutherland-Hodgman
            // Define edges in counter-clockwise order with inside on the left
            var clipped = vertices;

            // Bottom edge: (0, 0) → (width, 0), inside is above (y > 0)
            clipped = clipPolygonEdge(clipped, {x: 0, y: 0}, {x: width, y: 0}, true);

            // Right edge: (width, 0) → (width, height), inside is left (x < width)
            clipped = clipPolygonEdge(clipped, {x: width, y: 0}, {x: width, y: height}, true);

            // Top edge: (width, height) → (0, height), inside is below (y < height)
            clipped = clipPolygonEdge(clipped, {x: width, y: height}, {x: 0, y: height}, true);

            // Left edge: (0, height) → (0, 0), inside is right (x > 0)
            clipped = clipPolygonEdge(clipped, {x: 0, y: height}, {x: 0, y: 0}, true);

            return clipped;
        }

        function clipPolygonEdge(polygon, edgeP1, edgeP2, inside) {
            if (polygon.length === 0) return [];

            var output = [];
            var prevVertex = polygon[polygon.length - 1];

            polygon.forEach(function(vertex) {
                var prevInside = isLeftOfEdge(prevVertex, edgeP1, edgeP2) === inside;
                var vertexInside = isLeftOfEdge(vertex, edgeP1, edgeP2) === inside;

                if (vertexInside) {
                    if (!prevInside) {
                        var intersection = lineIntersection(prevVertex, vertex, edgeP1, edgeP2);
                        if (intersection) output.push(intersection);
                    }
                    output.push(vertex);
                } else if (prevInside) {
                    var intersection = lineIntersection(prevVertex, vertex, edgeP1, edgeP2);
                    if (intersection) output.push(intersection);
                }

                prevVertex = vertex;
            });

            return output;
        }

        function isLeftOfEdge(point, edgeP1, edgeP2) {
            return ((edgeP2.x - edgeP1.x) * (point.y - edgeP1.y) - (edgeP2.y - edgeP1.y) * (point.x - edgeP1.x)) > 0;
        }

        function lineIntersection(p1, p2, p3, p4) {
            var x1 = p1.x, y1 = p1.y;
            var x2 = p2.x, y2 = p2.y;
            var x3 = p3.x, y3 = p3.y;
            var x4 = p4.x, y4 = p4.y;

            var denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) return null;

            var t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;

            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }

        function sampleGradientColor(x, y, colors, gradientType) {
            var position = 0;

            switch(gradientType) {
                case 'linear-right':
                    position = x;
                    break;
                case 'linear-bottom':
                    position = y;
                    break;
                case 'linear-diagonal':
                    position = (x + y) / 2;
                    break;
                case 'radial':
                    var dx = x - 0.5;
                    var dy = y - 0.5;
                    position = Math.sqrt(dx * dx + dy * dy) * 2;
                    break;
            }

            // Clamp position
            position = Math.max(0, Math.min(1, position));

            // Find color stops
            var segmentCount = colors.length - 1;
            var segment = position * segmentCount;
            var index = Math.floor(segment);
            var fraction = segment - index;

            if (index >= colors.length - 1) {
                return colors[colors.length - 1];
            }

            // Interpolate between colors
            return interpolateColor(colors[index], colors[index + 1], fraction);
        }

        function interpolateColor(color1, color2, fraction) {
            var c1 = hexToRGB(color1);
            var c2 = hexToRGB(color2);

            var r = Math.round(c1[0] + (c2[0] - c1[0]) * fraction);
            var g = Math.round(c1[1] + (c2[1] - c1[1]) * fraction);
            var b = Math.round(c1[2] + (c2[2] - c1[2]) * fraction);

            return '#' + rgbToHex(r, g, b);
        }

        function applyDepthShading(baseColor, depthAmount) {
            if (depthAmount === 0) return baseColor;

            var rgb = hexToRGB(baseColor);
            var variation = (Math.random() - 0.5) * 2;
            var factor = 1 + (variation * (depthAmount / 100));

            var r = Math.max(0, Math.min(255, Math.round(rgb[0] * factor)));
            var g = Math.max(0, Math.min(255, Math.round(rgb[1] * factor)));
            var b = Math.max(0, Math.min(255, Math.round(rgb[2] * factor)));

            return '#' + rgbToHex(r, g, b);
        }

        function saveOverlaySettings() {
            localStorage.setItem('overlaySettings', JSON.stringify(overlaySettings));
        }

        function loadOverlaySettings() {
            var saved = localStorage.getItem('overlaySettings');
            if (saved) {
                overlaySettings = JSON.parse(saved);

                // Update UI
                qsa('.overlay-toggle').forEach(el => el.classList.remove('active'));
                const activeToggle = qs(`.overlay-toggle[data-overlay-enabled="${overlaySettings.enabled}"]`);
                if (activeToggle) activeToggle.classList.add('active');

                qs('#triangle-size').value = overlaySettings.triangleSize;
                qs('#size-value').textContent = overlaySettings.triangleSize;

                qs('#triangle-regularity').value = overlaySettings.regularity;
                qs('#regularity-value').textContent = overlaySettings.regularity;

                qs('#triangle-depth').value = overlaySettings.depth;
                qs('#depth-value').textContent = overlaySettings.depth;

                // Restore polygon type
                if (overlaySettings.polygonType) {
                    qsa('.polygon-type-option').forEach(el => el.classList.remove('active'));
                    const activeType = qs(`.polygon-type-option[data-polygon-type="${overlaySettings.polygonType}"]`);
                    if (activeType) activeType.classList.add('active');
                    var label = overlaySettings.polygonType === 'triangles' ? 'Triangles' : 'Voronoi';
                    qs('#polygon-type-value').textContent = label;
                }

                if (overlaySettings.enabled) {
                    qs('#overlay-parameters').style.display = 'block';
                }
            }
        }

        // Game functions
        function generateRandomColor() {
            return {
                r: Math.floor(Math.random() * 256),
                g: Math.floor(Math.random() * 256),
                b: Math.floor(Math.random() * 256)
            };
        }

        function startNewRound() {
            gameState.targetColor = generateRandomColor();
            gameState.guessColor = { r: 0, g: 0, b: 0 };
            gameState.hasGuessed = false;

            // Reset sliders
            qs('#game-red').value = 0;
            qs('#game-green').value = 0;
            qs('#game-blue').value = 0;
            qs('#game-r-value').textContent = 0;
            qs('#game-g-value').textContent = 0;
            qs('#game-b-value').textContent = 0;

            // Update display
            qs('#game-target').style.backgroundColor = `rgb(${gameState.targetColor.r}, ${gameState.targetColor.g}, ${gameState.targetColor.b})`;
            qs('#game-guess').style.backgroundColor = '#000';
            qs('#score-display').style.display = 'none';

            // Hide overlays until guess
            qs('#target-overlay').style.display = 'none';
            qs('#guess-overlay').style.display = 'none';
        }

        function updateGameGuessColor() {
            gameState.guessColor.r = parseInt(qs('#game-red').value);
            gameState.guessColor.g = parseInt(qs('#game-green').value);
            gameState.guessColor.b = parseInt(qs('#game-blue').value);

            qs('#game-r-value').textContent = gameState.guessColor.r;
            qs('#game-g-value').textContent = gameState.guessColor.g;
            qs('#game-b-value').textContent = gameState.guessColor.b;

            // Only update right side if already guessed
            if (gameState.hasGuessed) {
                qs('#game-guess').style.backgroundColor = `rgb(${gameState.guessColor.r}, ${gameState.guessColor.g}, ${gameState.guessColor.b})`;
            }
        }

        function calculateScore() {
            // Calculate how close each component is (0-255 range)
            var rDiff = Math.abs(gameState.targetColor.r - gameState.guessColor.r);
            var gDiff = Math.abs(gameState.targetColor.g - gameState.guessColor.g);
            var bDiff = Math.abs(gameState.targetColor.b - gameState.guessColor.b);

            // Calculate score for each component (0-100)
            var rScore = Math.round((1 - (rDiff / 255)) * 100);
            var gScore = Math.round((1 - (gDiff / 255)) * 100);
            var bScore = Math.round((1 - (bDiff / 255)) * 100);

            // Overall score is the average
            var totalScore = Math.round((rScore + gScore + bScore) / 3);

            return {
                total: totalScore,
                r: rScore,
                g: gScore,
                b: bScore,
                rDiff: rDiff,
                gDiff: gDiff,
                bDiff: bDiff
            };
        }

        function makeGuess() {
            gameState.hasGuessed = true;

            // Show the guessed color
            qs('#game-guess').style.backgroundColor = `rgb(${gameState.guessColor.r}, ${gameState.guessColor.g}, ${gameState.guessColor.b})`;

            // Calculate and display score
            var score = calculateScore();

            // Show and update overlays with results
            qs('#target-overlay').innerHTML = `<strong>Target</strong><br>R: ${gameState.targetColor.r}<br>G: ${gameState.targetColor.g}<br>B: ${gameState.targetColor.b}`;
            qs('#target-overlay').style.display = 'block';

            qs('#guess-overlay').innerHTML = `
                <strong>Your Guess</strong><br>
                R: ${gameState.guessColor.r} (${score.rDiff > 0 ? 'off by ' + score.rDiff : '✓'})<br>
                G: ${gameState.guessColor.g} (${score.gDiff > 0 ? 'off by ' + score.gDiff : '✓'})<br>
                B: ${gameState.guessColor.b} (${score.bDiff > 0 ? 'off by ' + score.bDiff : '✓'})
            `;
            qs('#guess-overlay').style.display = 'block';

            // Simplified score display
            var scoreHtml = `<div style="font-size: 2rem;">Score: ${score.total}/100</div>`;

            qs('#score-result').innerHTML = scoreHtml;
            qs('#score-display').style.display = 'block';
        }

        function createCanvasGradient(ctx, width, height, colorStops, gradientType) {
            var gradient;

            switch(gradientType) {
                case 'radial':
                    gradient = ctx.createRadialGradient(
                        width/2, height/2, 0,
                        width/2, height/2, Math.max(width, height)/2
                    );
                    break;
                case 'linear-bottom':
                    gradient = ctx.createLinearGradient(0, 0, 0, height);
                    break;
                case 'linear-diagonal':
                    gradient = ctx.createLinearGradient(0, 0, width, height);
                    break;
                default: // linear-right
                    gradient = ctx.createLinearGradient(0, 0, width, 0);
                    break;
            }

            colorStops.forEach(function(color, i) {
                gradient.addColorStop(i / (colorStops.length - 1), color);
            });

            return gradient;
        }

        function renderGradientToCanvas(canvas, colors, gradientType, withOverlay, settings) {
            var ctx = canvas.getContext('2d');
            var width = canvas.width;
            var height = canvas.height;

            // Step 1: Draw gradient background
            var colorStops = colors.length === 1 ? [colors[0], colors[0]] : colors;
            var gradient = createCanvasGradient(ctx, width, height, colorStops, gradientType);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Step 2: If overlay enabled, draw polygons
            if (withOverlay) {
                // Generate points
                var jitter = 100 - settings.regularity;
                var points = generatePoints(width, height, settings.triangleSize, jitter);

                // Triangulate
                var triangles = delaunayTriangulation(points);

                if (settings.polygonType === 'voronoi') {
                    // Compute and draw Voronoi cells
                    var voronoiCells = computeVoronoiDiagram(points, triangles, width, height);

                    voronoiCells.forEach(function(cell) {
                        // Sample color at cell center (the original point)
                        var normalizedX = cell.point.x / width;
                        var normalizedY = cell.point.y / height;
                        var baseColor = sampleGradientColor(normalizedX, normalizedY, colors, gradientType);
                        var finalColor = applyDepthShading(baseColor, settings.depth);

                        // Draw cell polygon
                        ctx.fillStyle = finalColor;
                        ctx.beginPath();
                        ctx.moveTo(cell.vertices[0].x, cell.vertices[0].y);
                        for (var i = 1; i < cell.vertices.length; i++) {
                            ctx.lineTo(cell.vertices[i].x, cell.vertices[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    });
                } else {
                    // Draw triangles
                    triangles.forEach(function(triangle) {
                        // Calculate centroid
                        var centroidX = (triangle.p1.x + triangle.p2.x + triangle.p3.x) / 3;
                        var centroidY = (triangle.p1.y + triangle.p2.y + triangle.p3.y) / 3;

                        // Sample gradient color at centroid
                        var normalizedX = centroidX / width;
                        var normalizedY = centroidY / height;
                        var baseColor = sampleGradientColor(normalizedX, normalizedY, colors, gradientType);

                        // Apply depth shading
                        var finalColor = applyDepthShading(baseColor, settings.depth);

                        // Draw triangle
                        ctx.fillStyle = finalColor;
                        ctx.beginPath();
                        ctx.moveTo(triangle.p1.x, triangle.p1.y);
                        ctx.lineTo(triangle.p2.x, triangle.p2.y);
                        ctx.lineTo(triangle.p3.x, triangle.p3.y);
                        ctx.closePath();
                        ctx.fill();
                    });
                }
            }
        }

        function switchToGradientMode(paletteId) {
            selectedPaletteId = paletteId;
            switchMode('gradient');
        }

        function renderAllPalettes() {
            const container = qs('#palettes-container');
            container.innerHTML = '';

            if (palettes.length === 0) {
                const emptyState = createElement('div', 'empty-state');
                emptyState.innerHTML = `
                    <div>No palettes yet</div>
                    <div style="font-size: 0.9rem; margin-top: 8px; opacity: 0.7;">Click "+ New Palette" below to get started</div>
                `;
                container.appendChild(emptyState);
                return;
            }

            palettes.forEach(function(palette) {
                const paletteId = palette.id;
                const row = createElement('div', 'palette-row');
                row.dataset.paletteId = paletteId;
                row.draggable = true;

                // Palette drag events
                row.addEventListener('dragstart', function(e) {
                    dragState.draggedPaletteId = paletteId;
                    row.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                row.addEventListener('dragend', function(e) {
                    row.classList.remove('dragging');
                    qsa('.palette-row').forEach(r => r.classList.remove('drag-over'));
                    dragState.draggedPaletteId = null;
                });

                row.addEventListener('dragover', function(e) {
                    // Only handle palette dragging, not swatch dragging
                    if (dragState.draggedPaletteId !== null &&
                        dragState.draggedSwatchIndex === null &&
                        dragState.draggedPaletteId !== paletteId) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        row.classList.add('drag-over');
                    }
                });

                row.addEventListener('dragleave', function(e) {
                    row.classList.remove('drag-over');
                });

                row.addEventListener('drop', function(e) {
                    // Only handle palette drops, not swatch drops
                    if (dragState.draggedPaletteId !== null &&
                        dragState.draggedSwatchIndex === null &&
                        dragState.draggedPaletteId !== paletteId) {
                        e.preventDefault();
                        row.classList.remove('drag-over');

                        // Find indices
                        const fromIndex = palettes.findIndex(p => p.id === dragState.draggedPaletteId);
                        const toIndex = palettes.findIndex(p => p.id === paletteId);

                        // Reorder array
                        const movedPalette = palettes.splice(fromIndex, 1)[0];
                        palettes.splice(toIndex, 0, movedPalette);

                        savePalettes();
                        renderAllPalettes();
                    }
                });

                const header = createElement('div', 'palette-header');
                header.addEventListener('click', function(e) {
                    selectedPaletteId = paletteId;
                    updatePaletteSelector();
                    updateGradientDisplay();
                });

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'palette-name';
                nameInput.value = palette.name;
                nameInput.addEventListener('click', function(e) {
                    if (currentMode === 'picker') {
                        e.stopPropagation();
                    }
                });
                nameInput.addEventListener('change', function() {
                    renamePalette(palette.id, this.value);
                });

                // Add preview swatches for gradient mode
                const previewContainer = createElement('div', 'palette-preview');
                previewContainer.addEventListener('click', function(e) {
                    e.stopPropagation();
                    selectedPaletteId = paletteId;
                    updatePaletteSelector();
                    updateGradientDisplay();
                });
                palette.colors.forEach(function(color) {
                    const previewSwatch = createElement('div', 'preview-swatch');
                    previewSwatch.style.backgroundColor = color;
                    previewContainer.appendChild(previewSwatch);
                });

                const actions = createElement('div', 'palette-actions');

                const gradientBtn = document.createElement('button');
                gradientBtn.className = `icon-btn ${palette.colors.length < 1 ? 'disabled' : ''}`;
                gradientBtn.title = 'View Gradient';
                gradientBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/></svg>';
                gradientBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (palette.colors.length >= 1) {
                        switchToGradientMode(palette.id);
                    }
                });

                const exportBtn = document.createElement('button');
                exportBtn.className = 'icon-btn';
                exportBtn.title = 'Export as SVG';
                exportBtn.textContent = '↓';
                exportBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    exportPaletteAsSVG(palette);
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'icon-btn';
                deleteBtn.title = 'Delete Palette';
                deleteBtn.textContent = '×';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deletePalette(palette.id);
                });

                actions.appendChild(gradientBtn);
                actions.appendChild(exportBtn);
                actions.appendChild(deleteBtn);
                header.appendChild(nameInput);
                header.appendChild(previewContainer);
                header.appendChild(actions);

                const swatchContainer = createElement('div', 'palette-container');

                // Allow dropping swatches on the container itself (for cross-palette copying to end)
                swatchContainer.addEventListener('dragover', function(e) {
                    if (dragState.draggedSwatchIndex !== null && dragState.draggedSwatchPaletteId !== paletteId) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'copy';
                    }
                });

                swatchContainer.addEventListener('drop', function(e) {
                    console.log('Container drop - target:', e.target, 'classes:', e.target.className);

                    // Handle drops on the container or the add button
                    if (dragState.draggedSwatchIndex !== null && dragState.draggedSwatchPaletteId !== paletteId) {
                        // Check if dropped on add button or container background
                        if (e.target === swatchContainer || e.target.classList.contains('add-to-palette')) {
                            console.log('Container/Add button drop - copying color');
                            e.preventDefault();

                            const sourcePalette = palettes.find(p => p.id === dragState.draggedSwatchPaletteId);
                            const draggedColor = sourcePalette.colors[dragState.draggedSwatchIndex];

                            if (palette.colors.length < 6 && !palette.colors.includes(draggedColor)) {
                                palette.colors.push(draggedColor);
                                savePalettes();
                                renderAllPalettes();
                            }
                        }
                    }
                });

                palette.colors.forEach(function(color, index) {
                    const swatch = createElement('div', 'swatch');
                    swatch.style.backgroundColor = color;
                    swatch.draggable = true;
                    swatch.dataset.swatchIndex = index;
                    swatch.dataset.paletteId = paletteId;

                    // Swatch drag events
                    swatch.addEventListener('dragstart', function(e) {
                        dragState.draggedSwatchIndex = index;
                        dragState.draggedSwatchPaletteId = paletteId;
                        swatch.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'copyMove';
                        e.stopPropagation();
                    });

                    swatch.addEventListener('dragend', function(e) {
                        swatch.classList.remove('dragging');
                        qsa('.swatch').forEach(s => s.classList.remove('drag-over'));
                        dragState.draggedSwatchIndex = null;
                        dragState.draggedSwatchPaletteId = null;
                    });

                    swatch.addEventListener('dragover', function(e) {
                        if (dragState.draggedSwatchIndex !== null) {
                            console.log('Dragover - Source:', dragState.draggedSwatchPaletteId, 'Target:', paletteId, 'Same?', dragState.draggedSwatchPaletteId === paletteId);
                            // Allow dropping on different palettes (copy) or same palette (reorder)
                            if (dragState.draggedSwatchPaletteId === paletteId) {
                                // Same palette - reorder (move)
                                if (dragState.draggedSwatchIndex !== index) {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'move';
                                    swatch.classList.add('drag-over');
                                }
                            } else {
                                // Different palette - copy
                                console.log('Different palette - allowing copy');
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'copy';
                                swatch.classList.add('drag-over');
                            }
                        }
                        e.stopPropagation();
                    });

                    swatch.addEventListener('dragleave', function(e) {
                        swatch.classList.remove('drag-over');
                    });

                    swatch.addEventListener('drop', function(e) {
                        console.log('Drop event fired!');
                        e.preventDefault();
                        e.stopPropagation();
                        swatch.classList.remove('drag-over');

                        if (dragState.draggedSwatchIndex !== null) {
                            const sourcePalette = palettes.find(p => p.id === dragState.draggedSwatchPaletteId);
                            const draggedColor = sourcePalette.colors[dragState.draggedSwatchIndex];
                            console.log('Drop - Source palette:', dragState.draggedSwatchPaletteId, 'Target palette:', paletteId);

                            if (dragState.draggedSwatchPaletteId === paletteId) {
                                // Same palette - reorder
                                console.log('Same palette - reordering');
                                if (dragState.draggedSwatchIndex !== index) {
                                    const fromIndex = dragState.draggedSwatchIndex;
                                    const toIndex = index;

                                    const movedColor = palette.colors.splice(fromIndex, 1)[0];
                                    palette.colors.splice(toIndex, 0, movedColor);

                                    savePalettes();
                                    renderAllPalettes();
                                }
                            } else {
                                // Different palette - copy color at this position
                                console.log('Different palette - copying. Length:', palette.colors.length, 'Color:', draggedColor, 'Already exists?', palette.colors.includes(draggedColor));
                                if (palette.colors.length < 6 && !palette.colors.includes(draggedColor)) {
                                    console.log('Copying color to palette');
                                    palette.colors.splice(index, 0, draggedColor);
                                    savePalettes();
                                    renderAllPalettes();
                                }
                            }
                        }
                    });

                    swatch.addEventListener('click', function(e) {
                        e.stopPropagation();
                        loadColor(color);

                        // Copy to clipboard
                        navigator.clipboard.writeText(color).then(() => {
                            showToast(`Copied ${color}`);
                            // Show visual feedback
                            const originalBg = swatch.style.backgroundColor;
                            swatch.style.outline = '3px solid rgba(255, 255, 255, 0.9)';
                            swatch.style.outlineOffset = '-3px';
                            setTimeout(() => {
                                swatch.style.outline = '';
                                swatch.style.outlineOffset = '';
                            }, 300);
                        });
                    });

                    const deleteSwatchBtn = createElement('div', 'delete-btn', '×');
                    deleteSwatchBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        removeFromPalette(palette.id, color);
                    });

                    swatch.appendChild(deleteSwatchBtn);
                    swatchContainer.appendChild(swatch);
                });

                // Only show add button if less than 6 colors
                if (palette.colors.length < 6) {
                    const addBtn = document.createElement('div');
                    addBtn.className = 'add-to-palette';
                    addBtn.textContent = '+';
                    addBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        addToPalette(palette.id);
                    });

                    swatchContainer.appendChild(addBtn);
                }
                row.appendChild(header);
                row.appendChild(swatchContainer);
                container.appendChild(row);
            });
        }

        document.addEventListener('DOMContentLoaded', function(){
            loadPalettes();
            loadOverlaySettings();
            switchMode('picker');

            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                // Don't trigger shortcuts when typing in input fields
                if (e.target.tagName === 'INPUT' && e.target.type === 'text') return;

                switch(e.key) {
                    case '1':
                        switchMode('picker');
                        showToast('Switched to Picker mode');
                        break;
                    case '2':
                        switchMode('gradient');
                        showToast('Switched to Gradient mode');
                        break;
                    case '3':
                        switchMode('game');
                        showToast('Switched to Game mode');
                        break;
                    case 'c':
                    case 'C':
                        if (currentMode === 'picker') {
                            navigator.clipboard.writeText(hex);
                            showToast(`Copied ${hex}`);
                        }
                        break;
                    case 'n':
                    case 'N':
                        if (currentMode === 'picker') {
                            createNewPalette();
                        }
                        break;
                }
            });

            // Event delegation for palette row clicks
            document.addEventListener('click', function(e) {
                if (e.target.closest('.palette-row')) {
                    const row = e.target.closest('.palette-row');
                    const paletteId = parseInt(row.dataset.paletteId);
                    selectedPaletteId = paletteId;
                    updatePaletteSelector();
                    updateGradientDisplay();
                }
            });

            qsa('.mode-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    switchMode(this.dataset.mode);
                });
            });

            qs('#new-palette-btn').addEventListener('click', function() {
                createNewPalette();
            });

            qs('#export-color-svg').addEventListener('click', function() {
                exportColorAsSVG(hex);
            });

            // Drag and drop for SVG import
            let dragCounter = 0;

            document.body.addEventListener('dragenter', function(e) {
                // Only show overlay when dragging files from outside (not internal palette/color dragging)
                if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                    e.preventDefault();
                    dragCounter++;
                    document.body.classList.add('drag-over');
                }
            });

            document.body.addEventListener('dragover', function(e) {
                // Only prevent default for file drops
                if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                    e.preventDefault();
                }
            });

            document.body.addEventListener('dragleave', function(e) {
                if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                    dragCounter--;
                    if (dragCounter === 0) {
                        document.body.classList.remove('drag-over');
                    }
                }
            });

            document.body.addEventListener('drop', function(e) {
                // Only handle file drops for import
                if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    dragCounter = 0;
                    handleDrop(e);
                }
            });

            // Color harmony click handlers
            qsa('.harmony-swatch').forEach(swatch => {
                swatch.addEventListener('click', function() {
                    const color = this.style.backgroundColor;
                    // Convert rgb() to hex
                    const rgb = color.match(/\d+/g);
                    if (rgb) {
                        const hexColor = '#' + rgbToHex(parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2]));
                        loadColor(hexColor);
                        showToast(`Loaded harmony color`);
                    }
                });
            });

            qsa('.gradient-option[data-gradient-type]').forEach(opt => {
                opt.addEventListener('click', function() {
                    selectGradientType(this.dataset.gradientType);
                });
            });

            qs('#copy-css-btn').addEventListener('click', function() {
                copyGradientCSS();
            });

            qs('#download-png-btn').addEventListener('click', function() {
                downloadGradientPNG();
            });

            // Overlay toggle
            qsa('.overlay-toggle').forEach(toggle => {
                toggle.addEventListener('click', function() {
                    var enabled = this.dataset.overlayEnabled === 'true';
                    overlaySettings.enabled = enabled;

                    qsa('.overlay-toggle').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');

                    if (enabled) {
                        qs('#overlay-parameters').style.display = 'block';
                    } else {
                        qs('#overlay-parameters').style.display = 'none';
                    }

                    updateGradientDisplay();
                    saveOverlaySettings();
                });
            });

            // Overlay parameter sliders
            qsa('.overlay-slider').forEach(slider => {
                slider.addEventListener('input', function() {
                    var value = parseInt(this.value);

                    switch(this.id) {
                        case 'triangle-size':
                            overlaySettings.triangleSize = value;
                            qs('#size-value').textContent = value;
                            break;
                        case 'triangle-regularity':
                            overlaySettings.regularity = value;
                            qs('#regularity-value').textContent = value;
                            break;
                        case 'triangle-depth':
                            overlaySettings.depth = value;
                            qs('#depth-value').textContent = value;
                            break;
                    }

                    updateGradientDisplay();
                    saveOverlaySettings();
                });
            });

            // Polygon type selector
            qsa('.polygon-type-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    var polygonType = this.dataset.polygonType;
                    overlaySettings.polygonType = polygonType;

                    qsa('.polygon-type-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');

                    var label = polygonType === 'triangles' ? 'Triangles' : 'Voronoi';
                    qs('#polygon-type-value').textContent = label;

                    updateGradientDisplay();
                    saveOverlaySettings();
                });
            });

            // Game event handlers
            qsa('.game-slider').forEach(slider => {
                slider.addEventListener('input', function() {
                    updateGameGuessColor();
                });
            });

            qs('#guess-btn').addEventListener('click', function() {
                makeGuess();
            });

            qs('#new-round-btn').addEventListener('click', function() {
                startNewRound();
            });

            qsa('.text').forEach(input => {
                input.addEventListener('input', function(){
                    var new_val = this.value;
                    if (isValidHexCode(new_val)) {
                        hex = new_val;
                        update('hex');
                    }
                });
            });

            // Add click-to-copy for hex input
            qs('#hex').addEventListener('click', function() {
                this.select();
                navigator.clipboard.writeText(this.value).then(() => {
                    showToast(`Copied ${this.value}`);
                    const originalColor = this.style.color;
                    this.style.color = 'rgba(255, 255, 255, 0.5)';
                    setTimeout(() => {
                        this.style.color = originalColor;
                    }, 200);
                });
            });

            qsa(".slider").forEach(slider => {
                slider.addEventListener("input", function(){
                    switch (this.id) {
                        case 'red':
                            red = parseInt(this.value);
                            break;
                        case 'green':
                            green = parseInt(this.value);
                            break;
                        case 'blue':
                            blue = parseInt(this.value);
                            break;
                        case 'brightness':
                            //Get current position of slider
                            var bright_val = qs('#brightness').value;

                            //Test based on direction of slider
                            if (bright_val > hold[3]) { //If slider going up
                                var red_slope = (255-hold[0])/(99-hold[3]);
                                red = hold[0] + Math.round(red_slope*(bright_val-hold[3]));

                                var green_slope = (255-hold[1])/(99-hold[3]);
                                green = hold[1] + Math.round(green_slope*(bright_val-hold[3]));

                                var blue_slope = (255-hold[2])/(99-hold[3]);
                                blue = hold[2] + Math.round(blue_slope*(bright_val-hold[3]));
                            }
                            else { //if slider going down
                                var red_slope = hold[0]/hold[3]-0;
                                red = hold[0] - Math.round(red_slope*(hold[3]-bright_val));

                                var green_slope = hold[1]/hold[3];
                                green = hold[1] - Math.round(green_slope*(hold[3]-bright_val));

                                var blue_slope = hold[2]/hold[3]-0;
                                blue = hold[2] - Math.round(blue_slope*(hold[3]-bright_val));
                            }
                            break;
                    }
                    update(this.id);
                });
            });
        });

    </script>
</head>

<body class="picker-mode">
    <div id="wrapper">
        <div id="fixed-header">
            <div id="mode-toggle">
                <button class="mode-btn active" data-mode="picker" aria-label="Picker mode (press 1)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" aria-hidden="true">
                        <line x1="4" y1="6" x2="20" y2="6"/>
                        <circle cx="14" cy="6" r="2" fill="currentColor"/>
                        <line x1="4" y1="12" x2="20" y2="12"/>
                        <circle cx="8" cy="12" r="2" fill="currentColor"/>
                        <line x1="4" y1="18" x2="20" y2="18"/>
                        <circle cx="16" cy="18" r="2" fill="currentColor"/>
                    </svg>
                </button>
                <button class="mode-btn" data-mode="gradient" aria-label="Gradient mode (press 2)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="3" y1="15" x2="21" y2="15"/>
                    </svg>
                </button>
                <button class="mode-btn" data-mode="game" aria-label="Game mode (press 3)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <circle cx="12" cy="12" r="6"/>
                        <circle cx="12" cy="12" r="2"/>
                    </svg>
                </button>
            </div>

            <div id="output">
                <div id="picker-content">
                    rgb: <div class='text' id="rgb">0,0,0</div><br/>
                    hex: <input class="text edit" id="hex" value="#000"><br/>
                    <button id="export-color-svg" class="icon-btn text" style="margin-top: 10px; background: transparent; border: none; cursor: pointer; font-size: 1.2rem;" title="Export as SVG">↓</button>
                </div>
                <div id="gradient-content">
                    <div id="gradient-preview"></div>
                    <canvas id="gradient-canvas" style="display: none;"></canvas>
                </div>
                <div id="game-content">
                    <div id="game-split">
                        <div id="game-target">
                            <div class="game-overlay" id="target-overlay">Target</div>
                        </div>
                        <div id="game-guess">
                            <div class="game-overlay" id="guess-overlay">Your Guess</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="scrollable-content">
            <div id="gradient-controls">
                <div class="control-group">
                    <label class="control-label">Gradient Type</label>
                    <div class="gradient-options">
                        <div class="gradient-option active" data-gradient-type="linear-right">Horizontal</div>
                        <div class="gradient-option" data-gradient-type="linear-bottom">Vertical</div>
                        <div class="gradient-option" data-gradient-type="linear-diagonal">Diagonal</div>
                        <div class="gradient-option" data-gradient-type="radial">Radial</div>
                    </div>
                </div>

                <div class="control-group" id="overlay-controls">
                    <label class="control-label">Low-Poly Overlay</label>
                    <div class="gradient-options">
                        <div class="gradient-option overlay-toggle active" data-overlay-enabled="false">Off</div>
                        <div class="gradient-option overlay-toggle" data-overlay-enabled="true">On</div>
                    </div>
                </div>

                <div class="control-group" id="overlay-parameters" style="display: none;">
                    <label class="control-label">
                        Polygon Size: <span id="size-value">50</span>
                    </label>
                    <input type="range" min="20" max="150" value="50" class="overlay-slider" id="triangle-size">

                    <label class="control-label">
                        Regularity: <span id="regularity-value">50</span>
                    </label>
                    <input type="range" min="0" max="100" value="50" class="overlay-slider" id="triangle-regularity">

                    <label class="control-label">
                        Depth: <span id="depth-value">30</span>
                    </label>
                    <input type="range" min="0" max="100" value="30" class="overlay-slider" id="triangle-depth">

                    <label class="control-label">
                        Polygon Type: <span id="polygon-type-value">Triangles</span>
                    </label>
                    <div class="gradient-options">
                        <div class="gradient-option polygon-type-option active" data-polygon-type="triangles">Triangles</div>
                        <div class="gradient-option polygon-type-option" data-polygon-type="voronoi">Voronoi</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="action-buttons">
                        <button class="action-btn" id="copy-css-btn">Copy CSS</button>
                        <button class="action-btn" id="download-png-btn">Download PNG</button>
                    </div>
                </div>
            </div>

            <div id="game-controls">
                <div class="control-group">
                    <label class="control-label">R: <span id="game-r-value">0</span></label>
                    <input type="range" min="0" max="255" value="0" class="game-slider" id="game-red">

                    <label class="control-label">G: <span id="game-g-value">0</span></label>
                    <input type="range" min="0" max="255" value="0" class="game-slider" id="game-green">

                    <label class="control-label">B: <span id="game-b-value">0</span></label>
                    <input type="range" min="0" max="255" value="0" class="game-slider" id="game-blue">
                </div>

                <div class="control-group">
                    <div class="action-buttons">
                        <button class="action-btn" id="guess-btn">Guess</button>
                        <button class="action-btn" id="new-round-btn">New Round</button>
                    </div>
                </div>

                <div class="control-group" id="score-display" style="display: none;">
                    <div id="score-result"></div>
                </div>
            </div>

            <input type="range" min="0" max="255" value="0" class="slider" id="red" aria-label="Red color value">
            <input type="range" min="0" max="255" value="0" class="slider" id="green" aria-label="Green color value">
            <input type="range" min="0" max="255" value="0" class="slider" id="blue" aria-label="Blue color value">
            <input type="range" min="0" max="99" value="0" class="slider" id="brightness" aria-label="Brightness">

            <div id="color-harmonies">
                <div class="harmony-section">
                    <div class="harmony-label">Complementary</div>
                    <div class="harmony-swatches">
                        <div class="harmony-swatch" id="harmony-comp"></div>
                    </div>
                </div>

                <div class="harmony-section">
                    <div class="harmony-label">Analogous</div>
                    <div class="harmony-swatches">
                        <div class="harmony-swatch" id="harmony-analog1"></div>
                        <div class="harmony-swatch" id="harmony-analog2"></div>
                    </div>
                </div>

                <div class="harmony-section">
                    <div class="harmony-label">Triadic</div>
                    <div class="harmony-swatches">
                        <div class="harmony-swatch" id="harmony-tri1"></div>
                        <div class="harmony-swatch" id="harmony-tri2"></div>
                    </div>
                </div>

                <div class="harmony-section">
                    <div class="harmony-label">Split Complementary</div>
                    <div class="harmony-swatches">
                        <div class="harmony-swatch" id="harmony-split1"></div>
                        <div class="harmony-swatch" id="harmony-split2"></div>
                    </div>
                </div>
            </div>

            <div id="palette-section">
                <div id="palettes-container"></div>
                <button id="new-palette-btn">+ New Palette</button>
            </div>
        </div>
    </div>
    <div id="toast"></div>
</body>