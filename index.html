<head>
    <title>swatch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23ff6b6b'/%3E%3Cstop offset='50%25' style='stop-color:%234ecdc4'/%3E%3Cstop offset='100%25' style='stop-color:%23ffe66d'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dongle:wght@700&family=Koulen&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background-color: #d3dcd9;
            margin: 0;
            padding: 0;
        }

        #wrapper {
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        #fixed-header {
            position: sticky;
            top: 0;
            background-color: #d3dcd9;
            padding: 20px;
            z-index: 100;
        }

        #scrollable-content {
            padding: 0 20px 20px 20px;
        }

        #mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            background-color: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            font-family: 'Koulen', cursive;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
        }

        body.dark-bg .mode-btn {
            color: rgba(255, 255, 255, 0.7);
        }

        .mode-btn.active {
            opacity: 1;
            border-bottom-color: rgba(0, 0, 0, 0.8);
        }

        body.dark-bg .mode-btn.active {
            border-bottom-color: rgba(255, 255, 255, 0.9);
        }

        .mode-btn:hover {
            opacity: 0.8;
        }

        #output {
            width: 100%;
            background-color: black;
            color: white;
            border-radius: 10px;
            font-family: 'Koulen', cursive;
            font-size: clamp(2rem, 8vw, 4rem);
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
            margin-bottom: 15px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body.dark-bg #output {
            box-shadow: 0 4px 8px 0 rgba(255, 255, 255, 0.1), 0 6px 20px 0 rgba(255, 255, 255, 0.05);
        }

        #picker-content {
            width: 100%;
            text-align: left;
            padding: 0 20px;
        }

        #gradient-content {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            overflow: hidden;
        }

        #gradient-preview {
            width: 100%;
            height: 100%;
        }

        #gradient-controls {
            display: none;
            margin-bottom: 15px;
        }

        body.gradient-mode #gradient-controls {
            display: block;
        }

        body.gradient-mode #picker-content {
            display: none;
        }

        body.gradient-mode #gradient-content {
            display: flex;
        }

        body.picker-mode #gradient-content {
            display: none;
        }

        body.gradient-mode #output {
            background: none !important;
            padding: 0;
        }

        body.gradient-mode .slider {
            display: none;
        }

        body.gradient-mode #palette-section {
            border-top: none;
            margin-top: 0;
            padding-top: 0;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            font-family: 'Koulen', cursive;
            font-size: 0.9rem;
            margin-bottom: 6px;
            display: block;
            opacity: 0.6;
        }

        body.dark-bg .control-label {
            color: rgba(255, 255, 255, 0.7);
        }

        #palette-selector-group {
            display: none;
        }

        .gradient-options {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .gradient-option {
            padding: 6px 12px;
            background-color: transparent;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Koulen', cursive;
            font-size: 0.9rem;
            transition: all 0.2s;
            opacity: 0.6;
        }

        body.dark-bg .gradient-option {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.8);
        }

        .gradient-option:hover {
            opacity: 0.8;
        }

        .gradient-option.active {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.08);
            border-color: rgba(0, 0, 0, 0.4);
        }

        body.dark-bg .gradient-option.active {
            background-color: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #overlay-controls {
            display: none;
        }

        body.gradient-mode #overlay-controls {
            display: block;
        }

        #gradient-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .overlay-slider {
            width: 100%;
            height: 30px;
            margin-bottom: 12px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            outline: none;
        }

        body.dark-bg .overlay-slider {
            background: rgba(255, 255, 255, 0.15);
        }

        .overlay-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            cursor: pointer;
        }

        body.dark-bg .overlay-slider::-webkit-slider-thumb {
            background: rgba(255, 255, 255, 0.8);
        }

        .overlay-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            cursor: pointer;
            border: none;
        }

        body.dark-bg .overlay-slider::-moz-range-thumb {
            background: rgba(255, 255, 255, 0.8);
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-family: 'Koulen', cursive;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            background-color: transparent;
        }

        body.dark-bg .action-btn {
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.9);
        }

        .action-btn:hover {
            background-color: rgba(0, 0, 0, 0.08);
        }

        body.dark-bg .action-btn:hover {
            background-color: rgba(255, 255, 255, 0.12);
        }

        .action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .text {
            background-color: transparent;
            color: white;
            border: 0;
            font-size: clamp(1.5rem, 6vw, 3rem);
            font-family: 'Koulen', cursive;
            max-width: 70%;
            display: inline-block;
        }

        input.text:focus {
            outline:none;
        }

        #rgb {
            white-space: nowrap;
        }

        .slider {
            border-radius: 10px;
            display: block;
            width: 100%;
            height: clamp(30px, 8vw, 50px);
            margin-bottom: 15px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, rgb(0, 0, 0), rgb(0, 0, 255));
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
            touch-action: none;
        }

        #red {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(255, 0, 0));
        }

        #green {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(0, 255, 0));
        }

        #blue {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(0, 0, 255));
        }

        #brightness {
        background: linear-gradient(to right, rgb(0, 0, 0), rgb(255, 255, 255));
    }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 60%;
            aspect-ratio: 1/1;
            border-radius: 45%;
            border: 3px solid white;
            background: rgba(255,255,255,0.35);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            height: clamp(18px, 5vw, 30px);
            width: clamp(18px, 5vw, 30px);
            border-radius: 50%;
            border: 3px solid white;
            background: rgba(255,255,255,0.35);
            cursor: pointer;
        }

        @media (max-width: 480px) {
            #wrapper {
                padding: 15px;
            }

            #output {
                padding: 20px;
                margin-bottom: 15px;
            }
        }

        @media (min-width: 768px) {
            #output {
                padding: 30px;
            }
        }

        #palette-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid rgba(0, 0, 0, 0.1);
        }

        .palette-row {
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 10px;
        }

        body.gradient-mode .palette-row {
            cursor: pointer;
            margin-bottom: 10px;
            padding: 10px;
            pointer-events: auto;
        }

        body.gradient-mode .palette-row:hover {
            background-color: rgba(0, 0, 0, 0.06);
        }

        body.gradient-mode .palette-row.selected {
            background-color: rgba(0, 0, 0, 0.15);
            outline: 3px solid rgba(0, 0, 0, 0.5);
            outline-offset: -3px;
        }

        body.dark-bg.gradient-mode .palette-row:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }

        body.dark-bg.gradient-mode .palette-row.selected {
            background-color: rgba(255, 255, 255, 0.15);
            outline: 3px solid rgba(255, 255, 255, 0.6);
            outline-offset: -3px;
        }

        .palette-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        body.gradient-mode .palette-header {
            margin-bottom: 0;
        }

        body.gradient-mode .palette-name {
            pointer-events: none;
            border-bottom-color: transparent !important;
        }

        .palette-preview {
            display: none;
            gap: 4px;
            margin-left: 10px;
        }

        body.gradient-mode .palette-preview {
            display: flex;
        }

        .preview-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        body.gradient-mode .palette-container {
            display: none;
        }

        body.gradient-mode .palette-actions,
        body.gradient-mode #new-palette-btn {
            display: none;
        }

        .palette-name {
            font-family: 'Koulen', cursive;
            font-size: 1.2rem;
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 5px;
            transition: border-color 0.2s;
        }

        .palette-name:hover {
            border-bottom-color: rgba(0, 0, 0, 0.2);
        }

        .palette-name:focus {
            outline: none;
            border-bottom-color: rgba(0, 0, 0, 0.5);
        }

        .palette-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border: none;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .icon-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .palette-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
        }

        .add-to-palette {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            background-color: transparent;
            border: 3px dashed rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .add-to-palette:hover {
            border-color: rgba(0, 0, 0, 0.5);
            color: rgba(0, 0, 0, 0.5);
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .add-to-palette:active {
            transform: scale(0.95);
        }

        .palette-colors {
            display: contents;
        }

        #new-palette-btn {
            width: 100%;
            padding: 12px;
            background-color: transparent;
            border: 2px dashed rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-family: 'Koulen', cursive;
            font-size: 1rem;
            color: rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.2s;
        }

        #new-palette-btn:hover {
            border-color: rgba(0, 0, 0, 0.4);
            color: rgba(0, 0, 0, 0.6);
            background-color: rgba(0, 0, 0, 0.02);
        }

        .swatch {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .swatch:active {
            transform: scale(0.95);
        }

        .swatch .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
        }

        .swatch:hover .delete-btn {
            display: flex;
        }

        @media (max-width: 480px) {
            .palette-container {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            }
        }

        /* Dark background adaptations */
        body.dark-bg #palette-section {
            border-top-color: rgba(255, 255, 255, 0.2);
        }

        body.dark-bg .palette-row {
            background-color: rgba(255, 255, 255, 0.05);
        }

        body.dark-bg .palette-name {
            color: rgba(255, 255, 255, 0.9);
        }

        body.dark-bg .palette-name:hover {
            border-bottom-color: rgba(255, 255, 255, 0.3);
        }

        body.dark-bg .palette-name:focus {
            border-bottom-color: rgba(255, 255, 255, 0.6);
        }

        body.dark-bg .icon-btn {
            background-color: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        body.dark-bg .icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.25);
        }

        body.dark-bg .add-to-palette {
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        body.dark-bg .add-to-palette:hover {
            border-color: rgba(255, 255, 255, 0.6);
            color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 8px rgba(255, 255, 255, 0.15);
        }

        body.dark-bg #new-palette-btn {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.5);
        }

        body.dark-bg #new-palette-btn:hover {
            border-color: rgba(255, 255, 255, 0.5);
            color: rgba(255, 255, 255, 0.7);
            background-color: rgba(255, 255, 255, 0.03);
        }

    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
    <script>
        var [red,green,blue]=[0,0,0];
        var hex = "000";
        var hold = [0,0,0];
        var palettes = [];
        var nextPaletteId = 1;
        var currentMode = 'picker';
        var selectedPaletteId = null;
        var currentGradientType = 'linear-right';
        var overlaySettings = {
            enabled: false,
            triangleSize: 50,
            regularity: 50,
            depth: 30,
            polygonType: 'triangles'
        };

        function update(elem){
            
            //Update RGB values if new hex code entered
            if (elem == "hex") {
                [red,green,blue] = hexToRGB(hex);
            }

            //Update red
            $('#red').css('background',"linear-gradient(to right, rgb(0,"+green+","+blue+"), rgb(255,"+green+","+blue+"))");

            //Update green
            $('#green').css('background',"linear-gradient(to right, rgb("+red+",0,"+blue+"), rgb("+red+",255,"+blue+"))");

            //Update blue
            $('#blue').css('background',"linear-gradient(to right, rgb("+red+","+green+",0), rgb("+red+","+green+",255))");

            //Update RGB sliders
            if(['brightness','hex'].includes(elem)){
                //If brightness slider, update sliders with new red,green,blue values. Don't update hold.
                $('#red').val(red);
                $('#green').val(green);
                $('#blue').val(blue);
            }

            if (['red','green','blue','hex'].includes(elem)) {
                //If non-brightness slider, store new color values in hold
                hold = [red,green,blue,get_brightness([red,green,blue])/2.55];
                   //Set gradient and position for brightness slider
                $('#brightness').css('background',"linear-gradient(to right, rgb(0,0,0), rgb("+hold[0]+","+hold[1]+","+hold[2]+") "+hold[3]+"%, rgb(255,255,255))");
                $('#brightness').val(hold[3]);
            }

            //Update readout
            $('#rgb').html(red+", "+green+", "+blue);

            if(!(['hex'].includes(elem))) {
                hex = "#"+rgbToHex(red,green,blue);
            }
            $('#hex').val(hex);

            $('#output, .text').css('background',hex);

            //Set text color
            var b = get_brightness();
            var contrast = Math.round((255-b)/255)*255;
            var contrast2 = 255-b;
            $('#output, .text').css('color', 'rgb('+(contrast)+','+contrast+','+contrast+')');
            const bgColor = 'rgb('+contrast2+','+contrast2+','+contrast2+')';
            $('body').css('background-color', bgColor);
            $('#fixed-header').css('background-color', bgColor);

            // Toggle dark background class for palette interface
            if (contrast2 < 128) {
                $('body').addClass('dark-bg');
            } else {
                $('body').removeClass('dark-bg');
            }
        };

        function rgbToHex(r, g, b) {
          if (r > 255 || g > 255 || b > 255 || r < 0 || g < 0 || b < 0)
        throw new Error('Invalid color component');
        return ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function isValidHexCode(str) {
        const regex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
        return regex.test(str);
        }

        function hexToRGB(hex) {
        // Remove the '#' from the beginning
        hex = hex.replace('#', '');
        
        // Check if the hex code is in the shorthand form (3 characters)
        if (hex.length === 3) {
            // Expand the shorthand form to full form (e.g., 'ABC' -> 'AABBCC')
            hex = hex.split('').map(char => char + char).join('');
        }

        // Convert hex code to an RGB array
        const rgb = [];
        for (let i = 0; i < hex.length; i += 2) {
            const decimalValue = parseInt(hex.substring(i, i + 2), 16);
            rgb.push(decimalValue);
        }

        return rgb;
        }

        function get_brightness(input=[red,green,blue]) {
            var b = 0;
            [red,green,blue].forEach(function(element){
                b += parseInt(element);
            });
            return Math.round(b/3);
        }

        function createNewPalette() {
            const palette = {
                id: nextPaletteId++,
                name: `Palette ${palettes.length + 1}`,
                colors: []
            };
            palettes.push(palette);
            savePalettes();
            renderAllPalettes();
        }

        function addToPalette(paletteId) {
            const palette = palettes.find(p => p.id === paletteId);
            // Ensure hex has # prefix
            const normalizedHex = hex.startsWith('#') ? hex : '#' + hex;
            if (palette && !palette.colors.includes(normalizedHex) && palette.colors.length < 6) {
                palette.colors.push(normalizedHex);
                savePalettes();
                renderAllPalettes();
            }
        }

        function removeFromPalette(paletteId, color) {
            const palette = palettes.find(p => p.id === paletteId);
            if (palette) {
                palette.colors = palette.colors.filter(c => c !== color);
                savePalettes();
                renderAllPalettes();
            }
        }

        function deletePalette(paletteId) {
            palettes = palettes.filter(p => p.id !== paletteId);
            // Reset selected palette if it was deleted
            if (selectedPaletteId === paletteId) {
                selectedPaletteId = palettes.length > 0 ? palettes[0].id : null;
                if (currentMode === 'gradient') {
                    updateGradientDisplay();
                }
            }
            savePalettes();
            renderAllPalettes();
        }

        function renamePalette(paletteId, newName) {
            const palette = palettes.find(p => p.id === paletteId);
            if (palette) {
                palette.name = newName;
                savePalettes();
            }
        }

        function loadColor(color) {
            hex = color;
            update('hex');
        }

        function savePalettes() {
            localStorage.setItem('colorPalettes', JSON.stringify({
                palettes: palettes,
                nextId: nextPaletteId
            }));
        }

        function loadPalettes() {
            const saved = localStorage.getItem('colorPalettes');
            if (saved) {
                const data = JSON.parse(saved);
                palettes = data.palettes || [];
                nextPaletteId = data.nextId || 1;

                // Fix any colors missing # prefix
                palettes.forEach(palette => {
                    palette.colors = palette.colors.map(color =>
                        color.startsWith('#') ? color : '#' + color
                    );
                });
                savePalettes(); // Save the fixed palettes
            }
            if (palettes.length === 0) {
                createNewPalette();
            }
            renderAllPalettes();
        }

        function switchMode(mode) {
            currentMode = mode;
            $('body').removeClass('picker-mode gradient-mode').addClass(mode + '-mode');
            $('.mode-btn').removeClass('active');
            $(`[data-mode="${mode}"]`).addClass('active');

            if (mode === 'gradient') {
                if (!selectedPaletteId && palettes.length > 0) {
                    selectedPaletteId = palettes[0].id;
                }
                updateGradientDisplay();
                updatePaletteSelector();
            }
        }

        function updatePaletteSelector() {
            // Update palette row selection in gradient mode
            $('.palette-row').removeClass('selected');
            $(`.palette-row[data-palette-id="${selectedPaletteId}"]`).addClass('selected');
        }

        function updateGradientDisplay() {
            const palette = palettes.find(p => p.id == selectedPaletteId);
            if (!palette || palette.colors.length === 0) {
                $('#gradient-preview').css('background', 'rgba(0,0,0,0.1)');
                $('#gradient-canvas').hide();
                $('.action-btn').prop('disabled', true);
                return;
            }

            $('.action-btn').prop('disabled', false);
            const colors = palette.colors.length === 1
                ? [palette.colors[0], palette.colors[0]]
                : palette.colors;

            if (overlaySettings.enabled) {
                // Switch to canvas rendering
                $('#gradient-preview').hide();
                $('#gradient-canvas').show();

                const canvas = document.getElementById('gradient-canvas');
                const container = document.getElementById('gradient-content');

                // Set canvas size to match container
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;

                // Render with overlay
                renderGradientToCanvas(
                    canvas,
                    colors,
                    currentGradientType,
                    true,
                    overlaySettings
                );
            } else {
                // Use CSS gradient
                $('#gradient-canvas').hide();
                $('#gradient-preview').show();

                const colorStops = colors.join(', ');
                let gradientCSS = '';

                switch(currentGradientType) {
                    case 'linear-right':
                        gradientCSS = `linear-gradient(to right, ${colorStops})`;
                        break;
                    case 'linear-bottom':
                        gradientCSS = `linear-gradient(to bottom, ${colorStops})`;
                        break;
                    case 'linear-diagonal':
                        gradientCSS = `linear-gradient(135deg, ${colorStops})`;
                        break;
                    case 'radial':
                        gradientCSS = `radial-gradient(circle, ${colorStops})`;
                        break;
                }

                $('#gradient-preview').css('background', gradientCSS);
            }
        }

        function selectGradientType(type) {
            currentGradientType = type;
            $('.gradient-option').removeClass('active');
            $(`[data-gradient-type="${type}"]`).addClass('active');
            updateGradientDisplay();
        }

        function copyGradientCSS() {
            const palette = palettes.find(p => p.id === selectedPaletteId);
            if (!palette || palette.colors.length < 2) return;

            const colorStops = palette.colors.join(', ');
            let gradientCSS = '';

            switch(currentGradientType) {
                case 'linear-right':
                    gradientCSS = `background: linear-gradient(to right, ${colorStops});`;
                    break;
                case 'linear-bottom':
                    gradientCSS = `background: linear-gradient(to bottom, ${colorStops});`;
                    break;
                case 'linear-diagonal':
                    gradientCSS = `background: linear-gradient(135deg, ${colorStops});`;
                    break;
                case 'radial':
                    gradientCSS = `background: radial-gradient(circle, ${colorStops});`;
                    break;
            }

            navigator.clipboard.writeText(gradientCSS).then(() => {
                const btn = $('#copy-css-btn');
                const originalText = btn.text();
                btn.text('Copied!');
                setTimeout(() => btn.text(originalText), 2000);
            });
        }

        function downloadGradientPNG() {
            const palette = palettes.find(p => p.id == selectedPaletteId);
            if (!palette || palette.colors.length === 0) return;

            const canvas = document.createElement('canvas');
            canvas.width = 1920;
            canvas.height = 1080;

            const colors = palette.colors.length === 1
                ? [palette.colors[0], palette.colors[0]]
                : palette.colors;

            // Render with or without overlay
            renderGradientToCanvas(
                canvas,
                colors,
                currentGradientType,
                overlaySettings.enabled,
                overlaySettings
            );

            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const overlayPrefix = overlaySettings.enabled ? 'lowpoly-' : '';
                a.download = `${overlayPrefix}gradient-${palette.name.toLowerCase().replace(/\s+/g, '-')}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Delaunay Triangulation - Bowyer-Watson Algorithm
        function delaunayTriangulation(points) {
            if (points.length < 3) return [];

            // Find bounding box
            var minX = Infinity, minY = Infinity;
            var maxX = -Infinity, maxY = -Infinity;
            points.forEach(function(p) {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });

            // Create super-triangle
            var dx = maxX - minX;
            var dy = maxY - minY;
            var deltaMax = Math.max(dx, dy) * 2;

            var p1 = {x: minX - 1, y: minY - 1};
            var p2 = {x: minX - 1, y: maxY + deltaMax};
            var p3 = {x: maxX + deltaMax, y: minY - 1};

            var triangles = [{p1: p1, p2: p2, p3: p3}];

            // Add points incrementally
            points.forEach(function(point) {
                var badTriangles = [];

                // Find bad triangles
                triangles.forEach(function(triangle) {
                    var circle = getCircumcircle(triangle.p1, triangle.p2, triangle.p3);
                    if (isInsideCircumcircle(point, circle)) {
                        badTriangles.push(triangle);
                    }
                });

                // Find boundary polygon
                var polygon = [];
                badTriangles.forEach(function(triangle) {
                    var edges = [
                        {p1: triangle.p1, p2: triangle.p2},
                        {p1: triangle.p2, p2: triangle.p3},
                        {p1: triangle.p3, p2: triangle.p1}
                    ];

                    edges.forEach(function(edge) {
                        var shared = false;
                        badTriangles.forEach(function(other) {
                            if (other === triangle) return;
                            if (edgeInTriangle(edge, other)) {
                                shared = true;
                            }
                        });

                        if (!shared) {
                            polygon.push(edge);
                        }
                    });
                });

                // Remove bad triangles
                triangles = triangles.filter(function(t) {
                    return badTriangles.indexOf(t) === -1;
                });

                // Add new triangles
                polygon.forEach(function(edge) {
                    triangles.push({
                        p1: edge.p1,
                        p2: edge.p2,
                        p3: point
                    });
                });
            });

            // Remove triangles connected to super-triangle
            triangles = triangles.filter(function(triangle) {
                return triangle.p1 !== p1 && triangle.p1 !== p2 && triangle.p1 !== p3 &&
                       triangle.p2 !== p1 && triangle.p2 !== p2 && triangle.p2 !== p3 &&
                       triangle.p3 !== p1 && triangle.p3 !== p2 && triangle.p3 !== p3;
            });

            return triangles;
        }

        function getCircumcircle(p1, p2, p3) {
            var ax = p1.x, ay = p1.y;
            var bx = p2.x, by = p2.y;
            var cx = p3.x, cy = p3.y;

            var d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 0.0001) {
                return {x: ax, y: ay, radius: Infinity};
            }

            var ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            var uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;

            var radius = Math.sqrt((ax - ux) * (ax - ux) + (ay - uy) * (ay - uy));

            return {x: ux, y: uy, radius: radius};
        }

        function isInsideCircumcircle(point, circle) {
            var dx = point.x - circle.x;
            var dy = point.y - circle.y;
            var distSq = dx * dx + dy * dy;
            return distSq < circle.radius * circle.radius;
        }

        function edgeInTriangle(edge, triangle) {
            var edges = [
                {p1: triangle.p1, p2: triangle.p2},
                {p1: triangle.p2, p2: triangle.p3},
                {p1: triangle.p3, p2: triangle.p1}
            ];

            for (var i = 0; i < edges.length; i++) {
                var e = edges[i];
                if ((e.p1 === edge.p1 && e.p2 === edge.p2) ||
                    (e.p1 === edge.p2 && e.p2 === edge.p1)) {
                    return true;
                }
            }
            return false;
        }

        function generatePoints(width, height, cellSize, jitter) {
            var points = [];
            var jitterAmount = cellSize * (jitter / 100);

            for (var y = -cellSize; y < height + cellSize; y += cellSize) {
                for (var x = -cellSize; x < width + cellSize; x += cellSize) {
                    var jitterX = (Math.random() - 0.5) * jitterAmount;
                    var jitterY = (Math.random() - 0.5) * jitterAmount;
                    points.push({
                        x: x + jitterX,
                        y: y + jitterY
                    });
                }
            }

            return points;
        }

        function computeVoronoiDiagram(points, triangles, width, height) {
            var cells = [];
            console.log('Computing Voronoi diagram with', points.length, 'points and', triangles.length, 'triangles');

            // Build point-to-triangles mapping
            var pointTriangles = {};
            points.forEach(function(p, i) {
                pointTriangles[i] = [];
            });

            triangles.forEach(function(tri) {
                // Find indices of triangle vertices in points array
                points.forEach(function(p, i) {
                    if (p === tri.p1 || p === tri.p2 || p === tri.p3) {
                        pointTriangles[i].push(tri);
                    }
                });
            });

            console.log('Point-to-triangles mapping built');

            // For each point, build its Voronoi cell
            points.forEach(function(point, pointIndex) {
                var tris = pointTriangles[pointIndex];
                if (tris.length === 0) return;

                // Get circumcenters of all triangles containing this point
                var circumcenters = tris.map(function(tri) {
                    var circle = getCircumcircle(tri.p1, tri.p2, tri.p3);
                    return {x: circle.x, y: circle.y, triangle: tri};
                });

                // Sort circumcenters in circular order around the point
                circumcenters.sort(function(a, b) {
                    var angleA = Math.atan2(a.y - point.y, a.x - point.x);
                    var angleB = Math.atan2(b.y - point.y, b.x - point.x);
                    return angleA - angleB;
                });

                // Extract vertices
                var vertices = circumcenters.map(function(cc) {
                    return {x: cc.x, y: cc.y};
                });

                // Clip cell to canvas bounds
                vertices = clipCellToCanvas(vertices, width, height);

                if (vertices.length >= 3) {
                    cells.push({
                        point: point,
                        vertices: vertices
                    });
                }
            });

            console.log('Generated', cells.length, 'Voronoi cells');
            return cells;
        }

        function clipCellToCanvas(vertices, width, height) {
            if (vertices.length === 0) return [];

            // Clip against four edges using Sutherland-Hodgman
            // Define edges in counter-clockwise order with inside on the left
            var clipped = vertices;
            console.log('Before clipping:', clipped.length, 'vertices');

            // Bottom edge: (0, 0) → (width, 0), inside is above (y > 0)
            clipped = clipPolygonEdge(clipped, {x: 0, y: 0}, {x: width, y: 0}, true);
            console.log('After bottom edge:', clipped.length, 'vertices');

            // Right edge: (width, 0) → (width, height), inside is left (x < width)
            clipped = clipPolygonEdge(clipped, {x: width, y: 0}, {x: width, y: height}, true);
            console.log('After right edge:', clipped.length, 'vertices');

            // Top edge: (width, height) → (0, height), inside is below (y < height)
            clipped = clipPolygonEdge(clipped, {x: width, y: height}, {x: 0, y: height}, true);
            console.log('After top edge:', clipped.length, 'vertices');

            // Left edge: (0, height) → (0, 0), inside is right (x > 0)
            clipped = clipPolygonEdge(clipped, {x: 0, y: height}, {x: 0, y: 0}, true);
            console.log('After left edge:', clipped.length, 'vertices');

            return clipped;
        }

        function clipPolygonEdge(polygon, edgeP1, edgeP2, inside) {
            if (polygon.length === 0) return [];

            var output = [];
            var prevVertex = polygon[polygon.length - 1];

            polygon.forEach(function(vertex) {
                var prevInside = isLeftOfEdge(prevVertex, edgeP1, edgeP2) === inside;
                var vertexInside = isLeftOfEdge(vertex, edgeP1, edgeP2) === inside;

                if (vertexInside) {
                    if (!prevInside) {
                        var intersection = lineIntersection(prevVertex, vertex, edgeP1, edgeP2);
                        if (intersection) output.push(intersection);
                    }
                    output.push(vertex);
                } else if (prevInside) {
                    var intersection = lineIntersection(prevVertex, vertex, edgeP1, edgeP2);
                    if (intersection) output.push(intersection);
                }

                prevVertex = vertex;
            });

            return output;
        }

        function isLeftOfEdge(point, edgeP1, edgeP2) {
            return ((edgeP2.x - edgeP1.x) * (point.y - edgeP1.y) - (edgeP2.y - edgeP1.y) * (point.x - edgeP1.x)) > 0;
        }

        function lineIntersection(p1, p2, p3, p4) {
            var x1 = p1.x, y1 = p1.y;
            var x2 = p2.x, y2 = p2.y;
            var x3 = p3.x, y3 = p3.y;
            var x4 = p4.x, y4 = p4.y;

            var denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) return null;

            var t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;

            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }

        function sampleGradientColor(x, y, colors, gradientType) {
            var position = 0;

            switch(gradientType) {
                case 'linear-right':
                    position = x;
                    break;
                case 'linear-bottom':
                    position = y;
                    break;
                case 'linear-diagonal':
                    position = (x + y) / 2;
                    break;
                case 'radial':
                    var dx = x - 0.5;
                    var dy = y - 0.5;
                    position = Math.sqrt(dx * dx + dy * dy) * 2;
                    break;
            }

            // Clamp position
            position = Math.max(0, Math.min(1, position));

            // Find color stops
            var segmentCount = colors.length - 1;
            var segment = position * segmentCount;
            var index = Math.floor(segment);
            var fraction = segment - index;

            if (index >= colors.length - 1) {
                return colors[colors.length - 1];
            }

            // Interpolate between colors
            return interpolateColor(colors[index], colors[index + 1], fraction);
        }

        function interpolateColor(color1, color2, fraction) {
            var c1 = hexToRGB(color1);
            var c2 = hexToRGB(color2);

            var r = Math.round(c1[0] + (c2[0] - c1[0]) * fraction);
            var g = Math.round(c1[1] + (c2[1] - c1[1]) * fraction);
            var b = Math.round(c1[2] + (c2[2] - c1[2]) * fraction);

            return '#' + rgbToHex(r, g, b);
        }

        function applyDepthShading(baseColor, depthAmount) {
            if (depthAmount === 0) return baseColor;

            var rgb = hexToRGB(baseColor);
            var variation = (Math.random() - 0.5) * 2;
            var factor = 1 + (variation * (depthAmount / 100));

            var r = Math.max(0, Math.min(255, Math.round(rgb[0] * factor)));
            var g = Math.max(0, Math.min(255, Math.round(rgb[1] * factor)));
            var b = Math.max(0, Math.min(255, Math.round(rgb[2] * factor)));

            return '#' + rgbToHex(r, g, b);
        }

        function saveOverlaySettings() {
            localStorage.setItem('overlaySettings', JSON.stringify(overlaySettings));
        }

        function loadOverlaySettings() {
            var saved = localStorage.getItem('overlaySettings');
            if (saved) {
                overlaySettings = JSON.parse(saved);

                // Update UI
                $('.overlay-toggle').removeClass('active');
                $(`.overlay-toggle[data-overlay-enabled="${overlaySettings.enabled}"]`).addClass('active');

                $('#triangle-size').val(overlaySettings.triangleSize);
                $('#size-value').text(overlaySettings.triangleSize);

                $('#triangle-regularity').val(overlaySettings.regularity);
                $('#regularity-value').text(overlaySettings.regularity);

                $('#triangle-depth').val(overlaySettings.depth);
                $('#depth-value').text(overlaySettings.depth);

                // Restore polygon type
                if (overlaySettings.polygonType) {
                    $('.polygon-type-option').removeClass('active');
                    $(`.polygon-type-option[data-polygon-type="${overlaySettings.polygonType}"]`).addClass('active');
                    var label = overlaySettings.polygonType === 'triangles' ? 'Triangles' : 'Voronoi';
                    $('#polygon-type-value').text(label);
                }

                if (overlaySettings.enabled) {
                    $('#overlay-parameters').show();
                }
            }
        }

        function createCanvasGradient(ctx, width, height, colorStops, gradientType) {
            var gradient;

            switch(gradientType) {
                case 'radial':
                    gradient = ctx.createRadialGradient(
                        width/2, height/2, 0,
                        width/2, height/2, Math.max(width, height)/2
                    );
                    break;
                case 'linear-bottom':
                    gradient = ctx.createLinearGradient(0, 0, 0, height);
                    break;
                case 'linear-diagonal':
                    gradient = ctx.createLinearGradient(0, 0, width, height);
                    break;
                default: // linear-right
                    gradient = ctx.createLinearGradient(0, 0, width, 0);
                    break;
            }

            colorStops.forEach(function(color, i) {
                gradient.addColorStop(i / (colorStops.length - 1), color);
            });

            return gradient;
        }

        function renderGradientToCanvas(canvas, colors, gradientType, withOverlay, settings) {
            var ctx = canvas.getContext('2d');
            var width = canvas.width;
            var height = canvas.height;

            // Step 1: Draw gradient background
            var colorStops = colors.length === 1 ? [colors[0], colors[0]] : colors;
            var gradient = createCanvasGradient(ctx, width, height, colorStops, gradientType);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Step 2: If overlay enabled, draw polygons
            if (withOverlay) {
                // Generate points
                var jitter = 100 - settings.regularity;
                var points = generatePoints(width, height, settings.triangleSize, jitter);

                // Triangulate
                var triangles = delaunayTriangulation(points);

                console.log('Polygon type:', settings.polygonType);
                if (settings.polygonType === 'voronoi') {
                    console.log('Rendering Voronoi cells');
                    // Compute and draw Voronoi cells
                    var voronoiCells = computeVoronoiDiagram(points, triangles, width, height);

                    voronoiCells.forEach(function(cell) {
                        // Sample color at cell center (the original point)
                        var normalizedX = cell.point.x / width;
                        var normalizedY = cell.point.y / height;
                        var baseColor = sampleGradientColor(normalizedX, normalizedY, colors, gradientType);
                        var finalColor = applyDepthShading(baseColor, settings.depth);

                        // Draw cell polygon
                        ctx.fillStyle = finalColor;
                        ctx.beginPath();
                        ctx.moveTo(cell.vertices[0].x, cell.vertices[0].y);
                        for (var i = 1; i < cell.vertices.length; i++) {
                            ctx.lineTo(cell.vertices[i].x, cell.vertices[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    });
                } else {
                    // Draw triangles
                    triangles.forEach(function(triangle) {
                        // Calculate centroid
                        var centroidX = (triangle.p1.x + triangle.p2.x + triangle.p3.x) / 3;
                        var centroidY = (triangle.p1.y + triangle.p2.y + triangle.p3.y) / 3;

                        // Sample gradient color at centroid
                        var normalizedX = centroidX / width;
                        var normalizedY = centroidY / height;
                        var baseColor = sampleGradientColor(normalizedX, normalizedY, colors, gradientType);

                        // Apply depth shading
                        var finalColor = applyDepthShading(baseColor, settings.depth);

                        // Draw triangle
                        ctx.fillStyle = finalColor;
                        ctx.beginPath();
                        ctx.moveTo(triangle.p1.x, triangle.p1.y);
                        ctx.lineTo(triangle.p2.x, triangle.p2.y);
                        ctx.lineTo(triangle.p3.x, triangle.p3.y);
                        ctx.closePath();
                        ctx.fill();
                    });
                }
            }
        }

        function switchToGradientMode(paletteId) {
            selectedPaletteId = paletteId;
            switchMode('gradient');
        }

        function renderAllPalettes() {
            $('#palettes-container').empty();

            palettes.forEach(function(palette) {
                const paletteId = palette.id;
                const row = $('<div class="palette-row"></div>')
                    .attr('data-palette-id', paletteId);

                const header = $('<div class="palette-header"></div>')
                    .on('click', function(e) {
                        selectedPaletteId = paletteId;
                        updatePaletteSelector();
                        updateGradientDisplay();
                    });
                const nameInput = $(`<input type="text" class="palette-name" value="${palette.name}" />`)
                    .on('click', function(e) {
                        if (currentMode === 'picker') {
                            e.stopPropagation();
                        }
                    })
                    .on('change', function() {
                        renamePalette(palette.id, $(this).val());
                    });

                // Add preview swatches for gradient mode
                const previewContainer = $('<div class="palette-preview"></div>')
                    .on('click', function(e) {
                        e.stopPropagation();
                        selectedPaletteId = paletteId;
                        updatePaletteSelector();
                        updateGradientDisplay();
                    });
                palette.colors.forEach(function(color) {
                    const previewSwatch = $('<div class="preview-swatch"></div>')
                        .css('background-color', color);
                    previewContainer.append(previewSwatch);
                });

                const actions = $('<div class="palette-actions"></div>');

                const gradientBtn = $(`<button class="icon-btn ${palette.colors.length < 1 ? 'disabled' : ''}" title="View Gradient">◨</button>`)
                    .on('click', function(e) {
                        e.stopPropagation();
                        if (palette.colors.length >= 1) {
                            switchToGradientMode(palette.id);
                        }
                    });

                const deleteBtn = $('<button class="icon-btn" title="Delete Palette">×</button>')
                    .on('click', function(e) {
                        e.stopPropagation();
                        if (confirm(`Delete "${palette.name}"?`)) {
                            deletePalette(palette.id);
                        }
                    });

                actions.append(gradientBtn, deleteBtn);
                header.append(nameInput, previewContainer, actions);

                const container = $('<div class="palette-container"></div>');

                palette.colors.forEach(function(color) {
                    const swatch = $('<div class="swatch"></div>')
                        .css('background-color', color)
                        .on('click', function(e) {
                            e.stopPropagation();
                            loadColor(color);
                        });

                    const deleteSwatchBtn = $('<div class="delete-btn">×</div>')
                        .on('click', function(e) {
                            e.stopPropagation();
                            removeFromPalette(palette.id, color);
                        });

                    swatch.append(deleteSwatchBtn);
                    container.append(swatch);
                });

                // Only show add button if less than 6 colors
                if (palette.colors.length < 6) {
                    const addBtn = $('<button class="add-to-palette">+</button>')
                        .on('click', function(e) {
                            e.stopPropagation();
                            addToPalette(palette.id);
                        });
                    container.append(addBtn);
                }
                row.append(header, container);
                $('#palettes-container').append(row);
            });
        }

        $(document).ready(function(){
            loadPalettes();
            loadOverlaySettings();
            switchMode('picker');

            // Event delegation for palette row clicks
            $('#palettes-container').on('click', '.palette-row', function(e) {
                const paletteId = parseInt($(this).attr('data-palette-id'));
                selectedPaletteId = paletteId;
                updatePaletteSelector();
                updateGradientDisplay();
            });

            $('.mode-btn').on('click', function() {
                switchMode($(this).data('mode'));
            });

            $('#new-palette-btn').on('click', function() {
                createNewPalette();
            });

            $('.gradient-option[data-gradient-type]').on('click', function() {
                selectGradientType($(this).data('gradient-type'));
            });

            $('#copy-css-btn').on('click', function() {
                copyGradientCSS();
            });

            $('#download-png-btn').on('click', function() {
                downloadGradientPNG();
            });

            // Overlay toggle
            $('.overlay-toggle').on('click', function() {
                var enabled = $(this).data('overlay-enabled');
                overlaySettings.enabled = enabled;

                $('.overlay-toggle').removeClass('active');
                $(this).addClass('active');

                if (enabled) {
                    $('#overlay-parameters').show();
                } else {
                    $('#overlay-parameters').hide();
                }

                updateGradientDisplay();
                saveOverlaySettings();
            });

            // Overlay parameter sliders
            $('.overlay-slider').on('input', function() {
                var value = parseInt($(this).val());

                switch(this.id) {
                    case 'triangle-size':
                        overlaySettings.triangleSize = value;
                        $('#size-value').text(value);
                        break;
                    case 'triangle-regularity':
                        overlaySettings.regularity = value;
                        $('#regularity-value').text(value);
                        break;
                    case 'triangle-depth':
                        overlaySettings.depth = value;
                        $('#depth-value').text(value);
                        break;
                }

                updateGradientDisplay();
                saveOverlaySettings();
            });

            // Polygon type selector
            $('.polygon-type-option').on('click', function() {
                var polygonType = $(this).data('polygon-type');
                console.log('Polygon type clicked:', polygonType);
                overlaySettings.polygonType = polygonType;

                $('.polygon-type-option').removeClass('active');
                $(this).addClass('active');

                var label = polygonType === 'triangles' ? 'Triangles' : 'Voronoi';
                $('#polygon-type-value').text(label);

                console.log('Updated overlay settings:', overlaySettings);
                updateGradientDisplay();
                saveOverlaySettings();
            });

            $('.text').on('input',function(){
                var new_val = $(this).val();
                if (isValidHexCode(new_val)) {
                    hex = new_val;
                    update('hex');
                }
             });


            $(".slider").on("input",function(){
                switch (this.id) {
                    case 'red':
                        red = parseInt($(this).val());
                        break;
                    case 'green':
                        green = parseInt($(this).val());
                        break;
                    case 'blue':
                        blue = parseInt($(this).val());
                        break;
                    case 'brightness':
                        //Get current position of slider
                        var bright_val = $('#brightness').val();
 
                        //Test based on direction of slider
                        if (bright_val > hold[3]) { //If slider going up
                            var red_slope = (255-hold[0])/(99-hold[3]);
                            red = hold[0] + Math.round(red_slope*(bright_val-hold[3]));

                            var green_slope = (255-hold[1])/(99-hold[3]);
                            green = hold[1] + Math.round(green_slope*(bright_val-hold[3]));

                            var blue_slope = (255-hold[2])/(99-hold[3]);
                            blue = hold[2] + Math.round(blue_slope*(bright_val-hold[3]));
                        }
                        else { //if slider going down
                            var red_slope = hold[0]/hold[3]-0;
                            red = hold[0] - Math.round(red_slope*(hold[3]-bright_val));

                            var green_slope = hold[1]/hold[3];
                            green = hold[1] - Math.round(green_slope*(hold[3]-bright_val));

                            var blue_slope = hold[2]/hold[3]-0;
                            blue = hold[2] - Math.round(blue_slope*(hold[3]-bright_val));
                        }
                        break;
                }
            update(this.id);
            });
        });

    </script>
</head>

<body class="picker-mode">
    <div id="wrapper">
        <div id="fixed-header">
            <div id="mode-toggle">
                <button class="mode-btn active" data-mode="picker">Picker</button>
                <button class="mode-btn" data-mode="gradient">Gradient</button>
            </div>

            <div id="output">
                <div id="picker-content">
                    rgb: <div class='text' id="rgb">0,0,0</div><br/>
                    hex: <input class="text edit" id="hex" value="#000">
                </div>
                <div id="gradient-content">
                    <div id="gradient-preview"></div>
                    <canvas id="gradient-canvas" style="display: none;"></canvas>
                </div>
            </div>
        </div>

        <div id="scrollable-content">
            <div id="gradient-controls">
                <div class="control-group">
                    <label class="control-label">Gradient Type</label>
                    <div class="gradient-options">
                        <div class="gradient-option active" data-gradient-type="linear-right">Horizontal</div>
                        <div class="gradient-option" data-gradient-type="linear-bottom">Vertical</div>
                        <div class="gradient-option" data-gradient-type="linear-diagonal">Diagonal</div>
                        <div class="gradient-option" data-gradient-type="radial">Radial</div>
                    </div>
                </div>

                <div class="control-group" id="overlay-controls">
                    <label class="control-label">Low-Poly Overlay</label>
                    <div class="gradient-options">
                        <div class="gradient-option overlay-toggle active" data-overlay-enabled="false">Off</div>
                        <div class="gradient-option overlay-toggle" data-overlay-enabled="true">On</div>
                    </div>
                </div>

                <div class="control-group" id="overlay-parameters" style="display: none;">
                    <label class="control-label">
                        Triangle Size: <span id="size-value">50</span>
                    </label>
                    <input type="range" min="20" max="150" value="50" class="overlay-slider" id="triangle-size">

                    <label class="control-label">
                        Regularity: <span id="regularity-value">50</span>
                    </label>
                    <input type="range" min="0" max="100" value="50" class="overlay-slider" id="triangle-regularity">

                    <label class="control-label">
                        Depth: <span id="depth-value">30</span>
                    </label>
                    <input type="range" min="0" max="100" value="30" class="overlay-slider" id="triangle-depth">

                    <label class="control-label">
                        Polygon Type: <span id="polygon-type-value">Triangles</span>
                    </label>
                    <div class="gradient-options">
                        <div class="gradient-option polygon-type-option active" data-polygon-type="triangles">Triangles</div>
                        <div class="gradient-option polygon-type-option" data-polygon-type="voronoi">Voronoi</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="action-buttons">
                        <button class="action-btn" id="copy-css-btn">Copy CSS</button>
                        <button class="action-btn" id="download-png-btn">Download PNG</button>
                    </div>
                </div>
            </div>

            <input type="range" min="0" max="255" value="0" class="slider" id="red">
            <input type="range" min="0" max="255" value="0" class="slider" id="green">
            <input type="range" min="0" max="255" value="0" class="slider" id="blue">
            <input type="range" min="0" max="99" value="0" class="slider" id="brightness">

            <div id="palette-section">
                <div id="palettes-container"></div>
                <button id="new-palette-btn">+ New Palette</button>
            </div>
        </div>
    </div>
</body>